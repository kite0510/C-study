# Chapter 17-1. 구조체

## 구조체의 필요성

*   배열은 모든 요소의 자료형이 같아야 합니다. 따라서 다양한 자료형의 데이터를 하나의 묶음으로 처리하기 어렵습니다.
*   구조체(structure)는 **다양한 자료형의 변수들을 하나로 묶어 새로운 자료형을 만드는 문법**입니다. 이를 통해 관련 있는 여러 데이터를 하나의 단위로 관리할 수 있습니다.

## 구조체 선언과 멤버 사용

*   **선언:** 구조체를 사용하기 전에 먼저 선언해야 합니다.
    ```c
    struct student {   // struct 예약어, student는 구조체 이름(태그)
        int num;       // int형 멤버
        double grade;  // double형 멤버
        // ... 다른 멤버들
    };                 // 선언 끝에는 세미콜론(;) 필수
    ```
    *   `struct student` 자체가 새로운 자료형이 됩니다.

*   **구조체 변수 선언:** 선언된 구조체 자료형으로 변수를 선언합니다.
    ```c
    struct student s1; // struct student 타입의 변수 s1 선언
    ```
    *   구조체 변수를 선언하면 각 멤버를 위한 메모리 공간이 할당됩니다.
    *   멤버들은 메모리에 (일반적으로) 선언된 순서대로 할당됩니다.

*   **멤버 접근:** 구조체 변수의 특정 멤버에 접근하려면 **멤버 접근 연산자 (`.`)**를 사용합니다.
    ```c
    구조체_변수명.멤버명
    ```
    *   `s1.num = 2;`: `s1` 변수의 `num` 멤버에 접근하여 2를 저장. (`s1.num`은 `int`형 변수처럼 동작)
    *   `s1.grade = 2.7;`: `s1` 변수의 `grade` 멤버에 접근하여 2.7을 저장. (`s1.grade`는 `double`형 변수처럼 동작)

## 구조체 변수의 크기 (바이트 얼라인먼트)

*   **기본:** 구조체 변수의 크기는 이론적으로 모든 멤버의 크기를 합한 값입니다.
*   **바이트 얼라인먼트 (Byte Alignment):**
    *   컴파일러는 메모리 접근 속도를 높이기 위해 구조체 멤버를 특정 바이트 단위(주로 가장 큰 멤버의 크기 또는 시스템 기본 단위)로 정렬합니다.
    *   이 과정에서 멤버 사이에 빈 공간(패딩 바이트, padding bytes)이 추가될 수 있습니다.
    *   따라서 구조체 변수의 실제 크기는 멤버 크기의 합보다 클 수 있습니다.
*   **예시:**
    ```c
    struct example {
        char c;     // 1 바이트
        int i;      // 4 바이트
        short s;    // 2 바이트
    };
    ```
    *   이론적인 크기는 1 + 4 + 2 = 7 바이트입니다.
    *   하지만 4바이트 정렬 시스템에서는 다음과 같이 할당될 수 있습니다:
        *   `c` (1) + 패딩 (3) + `i` (4) + `s` (2) + 패딩 (2) = 총 12 바이트
    *   멤버 선언 순서를 변경하면 패딩 바이트가 줄어들어 전체 크기가 달라질 수 있습니다. (큰 멤버부터 선언하는 것이 유리할 수 있음)
*   **패딩 비활성화:** `#pragma pack(1)` 지시문을 구조체 선언 전에 사용하면 패딩 바이트를 넣지 않아 메모리 크기를 최소화할 수 있습니다. (데이터 접근 속도는 느려질 수 있음)
    ```c
    #pragma pack(push, 1) // 현재 패킹 설정을 저장하고 1바이트 정렬 설정
    struct example {
        // ... 멤버 선언 ...
    };
    #pragma pack(pop)     // 이전 패킹 설정으로 복원
    ```
    *   주로 메모리가 제한적인 임베디드 시스템 등에서 사용됩니다.

## 다양한 구조체 멤버

구조체의 멤버로는 기본 자료형 외에도 다양한 형태를 사용할 수 있습니다.

*   **배열 멤버:**
    ```c
    struct profile {
        char name[20]; // 문자열 저장을 위한 char 배열 멤버
        // ...
    };
    ```
    *   배열 멤버에 문자열을 저장할 때는 `strcpy` 함수 등을 사용해야 합니다. (`strcpy(yuni.name, "서하윤");`)

*   **포인터 멤버:**
    ```c
    struct profile {
        // ...
        char *intro; // 문자열을 가리키는 포인터 멤버
    };
    ```
    *   포인터 멤버에 문자열 리터럴의 주소를 직접 대입할 수 있습니다. (`yuni.intro = "자기소개 내용";`)
    *   키보드 입력 등으로 문자열을 저장하려면, 먼저 `malloc` 등을 사용하여 메모리 공간을 *동적 할당*해야 합니다. (`yuni.intro = (char *)malloc(80);`)
    *   동적 할당된 메모리는 사용 후 반드시 `free` 함수로 해제해야 합니다.
    *   포인터 멤버는 다양한 길이의 데이터를 유연하게 처리할 수 있지만, 메모리 관리에 주의해야 합니다.

*   **다른 구조체 멤버:**
    ```c
    struct point {
        int x;
        int y;
    };

    struct rectangle {
        struct point p1; // point 구조체를 멤버로 가짐
        struct point p2;
    };
    ```
    *   구조체 안에 다른 구조체를 멤버로 포함할 수 있습니다.
    *   멤버에 접근할 때는 `.` 연산자를 두 번 사용합니다. (`rect.p1.x = 10;`)

## 구조체 변수의 초기화와 대입 연산

*   **초기화:** 구조체 변수를 선언과 동시에 초기화할 수 있습니다. 배열 초기화와 유사하게 중괄호 `{}`를 사용합니다.
    ```c
    struct student s1 = { 315, "홍길동", 2.4 }; // 멤버 선언 순서대로 초기값 지정
    ```
    *   구조체 정의와 변수 선언/초기화를 동시에 할 수도 있습니다.
    *   함수 외부(전역)에서 구조체 변수를 선언하고 초기화하지 않으면 모든 멤버가 0 또는 NULL로 자동 초기화됩니다.

*   **대입 연산:** 구조체 변수 간에는 대입 연산(`=`)이 가능합니다. 한 구조체 변수의 모든 멤버 값이 다른 구조체 변수로 복사됩니다.
    ```c
    struct student s2;
    s2 = s1; // s1의 모든 멤버 값이 s2로 복사됨
    ```

## 구조체 변수를 함수 매개변수에 사용하기

*   **값 전달 (Call by Value):** 구조체 변수를 함수의 인수로 전달하면, 구조체의 모든 멤버 값이 복사되어 함수에 전달됩니다.
    *   함수 내에서 매개변수로 받은 구조체 멤버를 변경해도, 원본 구조체 변수에는 영향을 주지 않습니다.
*   **구조체 반환:** 함수는 구조체 변수를 반환할 수 있습니다. 이를 통해 여러 개의 값을 하나의 구조체로 묶어 반환할 수 있습니다.

    ```c
    struct vision exchange(struct vision robot) { // 구조체를 매개변수로 받고
        // ... 값 교환 로직 ...
        return robot; // 교환된 구조체를 반환
    }

    // main 함수에서:
    robot = exchange(robot); // 함수 호출 및 반환된 구조체 대입
    ```

*   **연산자 우선순위:** 멤버 접근 연산자 (`.`)는 주소 연산자 (`&`)보다 우선순위가 높습니다.
    *   `&(robot.left)`: `robot`의 `left` 멤버에 먼저 접근한 후, 그 멤버의 주소를 구합니다. (괄호 불필요)
