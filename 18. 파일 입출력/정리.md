# Chapter 18. 파일 입출력 (File I/O)
---
## 18-1. 파일 개방과 입출력 (File Opening and I/O)
---

### 파일 개방과 폐쇄 (Opening and Closing Files)

파일에 데이터를 입출력하기 위해서는 먼저 **어떤 용도로 사용할지 결정**한 후, 원하는 데이터 파일을 하드디스크에서 찾아야 합니다. 데이터를 입출력하기 전에 준비하는 이러한 과정을 **파일 개방(File Opening)**이라고 합니다. 사용이 끝난 파일은 **닫는 과정인 파일 폐쇄(File Closing)**도 필요합니다. 이 두 과정은 모두 함수 호출로 수행됩니다: `fopen`과 `fclose`.

*   **파일 개방: `fopen()` 함수**

    *   **원형:** `FILE *fopen(const char *filename, const char *mode);`
    *   **설명:** `fopen` 함수에 **파일명(`filename`)**과 **개방 모드(`mode`)**를 문자열로 전달하면, 함수는 원하는 파일을 찾아 개방합니다.
        ```c
        FILE *fp; // 파일 포인터 선언
        fp = fopen("a.txt", "r"); // "a.txt" 파일을 읽기 모드로 개방
        ```
    *   **파일 경로:**
        *   `fopen` 함수가 파일을 찾는 기본 위치는 **[현재 작업 디렉터리]**입니다. 이는 일반적으로 실행 파일이 있는 위치, 즉 프로그램이 실행되는 디렉터리입니다.
        *   다른 위치에 있는 파일을 개방하려면, 파일명에 **경로(Path)**를 함께 명시해야 합니다.
        *   **경로 포함 예시 (Windows):**
            ```c
            fp = fopen("c:\\source\\a.txt", "r");
            ```
            **주의:** 문자열 안에서 백슬래시(`\`)는 제어 문자의 시작을 의미하므로, 디렉터리 구분 기호로 사용될 때는 **두 번(`\\`)** 써야 합니다. 또는 슬래시(`/`)를 사용할 수도 있습니다 (`"c:/source/a.txt"`).
    *   **개방 모드 (`mode`):** 파일의 사용 용도를 지정하는 문자열입니다.

        | 모드 | 설명                                       | 파일이 있을 때           | 파일이 없을 때         |
        | :--- | :----------------------------------------- | :----------------------- | :--------------------- |
        | `r`  | 읽기 위해 개방 (Read)                      | 파일 처음부터 읽기 시작   | **오류 (NULL 반환)**   |
        | `w`  | 쓰기 위해 개방 (Write)                     | **기존 내용 모두 삭제**   | **새 파일 생성**       |
        | `a`  | 추가하기 위해 개방 (Append)                | 파일의 **끝에** 내용 추가 | **새 파일 생성**       |
        | `r+` | 텍스트 파일 읽고 쓰기 위해 개방            | 파일 처음부터 읽/쓰기    | **오류 (NULL 반환)**   |
        | `w+` | 텍스트 파일 읽고 쓰기 위해 개방            | **기존 내용 모두 삭제**   | **새 파일 생성**       |
        | `a+` | 텍스트 파일 읽거나 파일 끝에 추가하기 위해 개방 | 읽기는 처음부터, 쓰기는 끝에 | **새 파일 생성**       |
        | `b`  | 바이너리(이진) 모드                        | -                        | -                      |

        *   `b`를 모드 문자열에 추가하면(예: `"rb"`, `"wb"`, `"ab"`), 바이너리 모드로 개방됩니다.
        *   `t`(텍스트 모드)는 기본값이므로 보통 생략합니다.
    *   **반환값:**
        *   `fopen` 함수가 파일을 성공적으로 개방하면, 해당 파일에 연결된 **파일 포인터(`FILE *`)**를 반환합니다.
        *   파일 포인터는 **스트림 파일(Stream File)**에 접근할 수 있게 해주는 포인터입니다. `fopen` 함수는 실제 파일 장치와 연결되는 스트림 파일을 메모리에 만들고, 이 스트림 파일 구조체(`FILE`)의 주소를 반환합니다.
        *   파일 개방에 **실패하면 `NULL` (널 포인터)**을 반환합니다.
    *   **`NULL` 포인터:**
        *   `NULL`은 0번지를 이름으로 정의해서 사용하는 것으로, `stdio.h` 헤더 파일에 일반적으로 다음과 같이 정의되어 있습니다:
          ```c
          #define NULL ((void *)0)
          ```
        *   `NULL`은 포인터를 반환하는 함수에서 **예외 상황(오류)**을 알리기 위해 사용됩니다. `NULL` 포인터는 간접 참조(`*`)하여 사용할 수 없습니다.
    *   **오류 검사 (필수):** `fopen` 함수 호출 후에는 반드시 반환값을 검사하여 파일이 정상적으로 열렸는지 확인해야 합니다.
        ```c
        FILE *fp = fopen("data.txt", "r");
        if (fp == NULL) { // 또는 if (!fp)
            printf("파일이 열리지 않았습니다.\n");
            return 1; // 오류 처리
        }
        ```
    *   **모드별 동작 상세:**
        *   `r` 모드: 파일이 없으면 `NULL` 반환.
        *   `w` 모드: 파일이 없으면 **빈 새 파일을 생성**하여 개방합니다. 파일이 **있으면 기존 내용을 모두 지우고** 개방하므로 **주의**해야 합니다.
        *   `a` 모드: 파일이 없으면 **빈 새 파일을 생성**하여 개방합니다. 파일이 있으면 기존 내용을 지우지 않고, 데이터를 쓸 때 항상 **파일의 끝에 추가**합니다.
        *   비록 `w`와 `a` 모드가 파일이 없어도 파일을 생성하지만, 프로그램이 개방할 수 있는 파일 수 제한 초과나 하드 디스크 문제 등으로 개방에 실패할 수 있으므로, **모든 모드에서 `fopen` 후에는 개방 여부를 검사하는 것이 안전합니다.**

*   **파일 폐쇄: `fclose()` 함수**

    *   **원형:** `int fclose(FILE *stream);`
    *   **설명:** 개방했던 파일을 더 이상 사용하지 않을 때, 해당 파일의 파일 포인터(`stream`)를 인수로 주어 파일을 닫습니다.
    *   **반환값:**
        *   성공 시: `0` 반환.
        *   오류 발생 시: `EOF` 반환 (`stdio.h`에 `-1`로 정의된 상수).
        ```c
        #define EOF (-1)
        ```
    *   **필요성:**
        *   파일 개방을 통해 만들어진 스트림 파일은 메모리를 사용합니다. `fclose`는 이 메모리를 시스템에 반환하여 재활용할 수 있게 합니다.
        *   출력 버퍼에 남아있는 데이터가 있다면, 이를 실제 파일 장치에 기록합니다. (데이터 손실 방지)
        *   **사용이 끝난 파일은 즉시 닫는 것이 좋습니다.**

---

### 스트림 파일과 파일 포인터 (Stream Files and File Pointers)

*   **스트림 파일(Stream File):** 프로그램과 입출력 장치(파일, 키보드, 모니터 등) 사이의 **다리 역할**을 하는 **논리적인 파일**입니다. 실제 물리적 장치에 직접 접근하는 대신 스트림을 통해 데이터를 주고받습니다.
*   **버퍼(Buffer):** 스트림 파일은 내부에 **문자 배열 형태의 버퍼**를 가지고 있습니다. 버퍼는 데이터를 임시로 저장하여 입출력 효율을 높입니다.
*   **`FILE` 구조체:**
    *   스트림 파일은 파일 입출력에 필요한 여러 정보(버퍼의 메모리 위치, 버퍼의 크기, 현재 읽거나 쓸 위치를 나타내는 **위치 지시자(Position Indicator)** 등)를 관리해야 합니다.
    *   이러한 정보들을 **구조체**로 묶어서 보관하는데, 이 구조체의 이름이 **`FILE`**입니다.
    *   `fopen` 함수는 메모리에 스트림 파일을 위한 `FILE` 구조체 변수를 만들고, 프로그램에서 이 구조체를 사용할 수 있도록 그 **주소(파일 포인터)**를 반환하는 것입니다.
*   **스트림 파일 사용의 장점:**
    1.  **입출력 효율 향상 및 장치 독립성:**
        *   버퍼링을 통해 실제 장치 접근 횟수를 줄여 효율을 높입니다.
        *   프로그램은 표준화된 스트림 인터페이스를 사용하므로, 입출력 장치가 바뀌어도 프로그램 코드를 크게 수정할 필요가 없습니다. (장치로부터 독립된 프로그래밍 가능)
    2.  **입출력 속도 차이 완충:**
        *   CPU의 데이터 처리 속도와 하드디스크 같은 입출력 장치의 속도는 매우 차이가 큽니다.
        *   **출력 시:** 버퍼에 데이터를 모았다가 한꺼번에 장치로 보내면, 장치가 데이터를 기록하는 동안 프로그램은 다음 데이터를 버퍼에 채울 수 있습니다.
        *   **입력 시:** 장치에서 미리 데이터를 읽어와 버퍼에 저장해두면, 프로그램은 필요할 때 버퍼에서 빠르게 데이터를 가져갈 수 있습니다.

---

### 문자 단위 입출력 (Character I/O)

파일이 개방되면 실질적인 데이터 입출력은 파일 입출력 함수들을 통해 수행됩니다. 이때 함수의 인수로 `fopen`이 반환한 파일 포인터를 사용합니다.

*   **문자 입력: `fgetc()` 함수**

    *   **원형:** `int fgetc(FILE *stream);`
    *   **설명:** `stream`(파일 포인터)으로 지정된 파일에서 **하나의 문자**를 입력받아 반환합니다.
    *   **반환값:**
        *   성공 시: 읽어 들인 문자의 아스키 코드 값 (`int`형).
        *   파일의 데이터를 모두 읽었거나 오류 발생 시: `EOF` (`-1`) 반환.
    *   **동작 과정 (버퍼링과 위치 지시자):**
        1.  `fgetc` 함수는 파일 포인터와 연결된 스트림 파일의 **버퍼**에서 데이터를 가져옵니다.
        2.  **처음 호출 시:** 버퍼가 비어 있으므로, 하드디스크의 파일로부터 데이터를 읽어와 버퍼를 채웁니다. 이때 한 번에 버퍼 크기만큼 데이터를 가져와 저장합니다. (파일 크기가 버퍼보다 작으면 모든 데이터가 한 번에 저장됩니다.)
        3.  버퍼가 채워진 후, `fgetc`는 버퍼의 **첫 번째 문자**를 가져와 반환합니다.
        4.  **두 번째 호출 시:** 이미 버퍼에 데이터가 있으므로, 하드디스크 접근 없이 버퍼로부터 바로 다음 문자를 읽어 반환합니다.
        5.  이 과정은 스트림 파일 내의 **위치 지시자(Position Indicator)** 덕분에 가능합니다. 파일이 개방되면 위치 지시자는 0으로 초기화되며, 입력 함수가 데이터를 읽을 때마다 읽은 크기만큼 자동으로 증가합니다. `fgetc`는 한 문자씩 읽으므로 위치 지시자 값이 1씩 증가합니다.
        6.  버퍼의 데이터를 모두 읽으면 (위치 지시자 값이 버퍼에 저장된 데이터 크기와 같아지면), 다음 `fgetc` 호출 시 다시 하드디스크로부터 새로운 데이터를 읽어와 버퍼를 채웁니다.
        7.  만약 하드디스크에 더 이상 읽을 데이터가 없으면, `fgetc` 함수는 `EOF`를 반환합니다.
    *   **`EOF` 사용:** `EOF`는 `stdio.h`에 정의된 상수 `-1`입니다. `-1`을 직접 사용하는 것보다 호환성을 위해 `EOF`를 사용하는 것이 좋습니다. `fgetc`는 파일 크기와 읽어들인 데이터 크기를 비교하여 파일 끝을 판단합니다.

*   **문자 출력: `fputc()` 함수**

    *   **원형:** `int fputc(int character, FILE *stream);`
    *   **설명:** `character`로 주어진 한 문자를 `stream`(파일 포인터)이 가리키는 파일로 출력합니다.
    *   **반환값:**
        *   성공 시: 출력한 문자를 다시 반환합니다.
        *   오류 발생 시: `EOF`를 반환합니다.
    *   **동작 과정 (버퍼링):**
        *   `fputc` 함수도 출력 과정에서 스트림 파일의 **버퍼**를 사용합니다. 문자가 하나씩 하드디스크에 직접 저장되는 것이 아니라, 버퍼에 데이터가 모인 후에 한 번에 출력됩니다.
        *   **버퍼의 데이터가 실제 파일에 쓰이는 시점:**
            1.  버퍼가 가득 찼을 때
            2.  개행 문자(`\n`)를 출력할 때 (텍스트 모드)
            3.  `fflush()` 함수를 호출할 때
            4.  `fclose()` 함수를 호출하여 파일을 닫을 때
            5.  프로그램이 정상적으로 종료될 때
            6.  새로운 입력 함수가 호출될 때 (일부 시스템)
        *   **주의:** 버퍼에 데이터가 남아있는 상태에서 프로그램이 비정상적으로 종료되거나 전원이 꺼지면 데이터가 파일에 저장되지 않고 **유실될 수 있습니다.**
        *   **`fflush()` 함수:** 버퍼의 데이터를 즉시 장치(파일)로 출력(flush)해야 할 경우 사용합니다. (자세한 내용은 후술)

---

### 기본적으로 개방되는 표준 입출력 스트림 (Standard I/O Streams)

C 프로그램이 시작될 때 운영체제는 기본적으로 다음 3개의 스트림 파일을 개방하고 프로그램과 연결합니다.

*   `stdin`: **표준 입력 스트림 (Standard Input)** - 기본 장치: **키보드**
*   `stdout`: **표준 출력 스트림 (Standard Output)** - 기본 장치: **모니터**
*   `stderr`: **표준 에러 스트림 (Standard Error)** - 기본 장치: **모니터**

*   `stdin`, `stdout`, `stderr`는 운영체제가 미리 개방한 파일 포인터(엄밀히는 `FILE` 구조체를 가리키는 포인터)를 의미합니다.
*   `getchar()`, `putchar()`, `scanf()`, `printf()` 등의 표준 입출력 함수들은 내부적으로 이 표준 스트림 파일들을 사용합니다.
    *   예: `getchar()`는 `stdin` 스트림 파일의 버퍼를 통해 키보드 입력을 받습니다. 처음 호출 시 입력한 내용(엔터 포함)이 버퍼에 저장되고, 이후 호출 시 버퍼에서 차례대로 문자를 가져옵니다.
*   **EOF 입력:** 키보드로 파일의 끝(EOF)을 나타내는 문자를 입력할 수 있습니다.
    *   Windows: `Ctrl + Z` 입력 후 `Enter`
    *   Unix/Linux: `Ctrl + D`
*   `fgetc()`, `fputc()` 등의 파일 입출력 함수에서도 `stdin`, `stdout`, `stderr`를 파일 포인터 인수로 직접 사용할 수 있습니다.
    ```c
    int ch = fgetc(stdin);      // 키보드에서 문자 입력 (getchar()와 유사)
    fputc(ch, stdout);          // 모니터로 문자 출력 (putchar(ch)와 유사)
    fprintf(stderr, "Error!\n"); // 에러 메시지를 모니터로 출력
    ```
    이렇게 하면 별도의 파일을 개방하지 않고도 운영체제가 기본 연결해 놓은 장치(키보드, 모니터)로 입출력을 수행할 수 있습니다.

---

### 텍스트 파일과 바이너리 파일 (Text vs. Binary Files)

파일은 데이터를 기록하는 방식에 따라 **텍스트 파일**과 **바이너리 파일**로 나뉩니다.

*   **텍스트 파일 (Text File):**
    *   데이터를 **아스키(ASCII) 코드 값**에 따라 문자로 저장한 파일입니다.
    *   메모장 같은 텍스트 편집기로 내용을 확인하고 편집할 수 있습니다.
    *   개방 모드에 `t`를 쓰거나, 아무것도 쓰지 않으면 텍스트 모드로 개방됩니다. (`"r"`, `"wt"`, `"a+"` 등)
    *   **특징 (특히 Windows):**
        1.  **개행 문자(Newline) 변환:** 파일에 쓸 때 `\n`(LF, 아스키 10) 문자가 `\r\n`(CRLF, 아스키 13, 10)으로 변환되고, 읽을 때는 `\r\n`이 다시 `\n`으로 변환됩니다. (이 때문에 파일 크기가 실제 데이터 크기와 다를 수 있습니다.)
        2.  **EOF 문자:** `Ctrl+Z`(SUB, 아스키 26) 문자를 파일의 끝으로 인식할 수 있습니다.

*   **바이너리 파일 (Binary File):**
    *   텍스트 파일 이외의 방식으로 저장된 모든 파일입니다. 즉, 데이터를 메모리에 있는 **이진(binary) 형태 그대로** 저장합니다.
    *   데이터 변환이 일어나지 않으므로, 실행 파일, 이미지 파일, 데이터 파일 등 다양한 형식의 파일을 다룰 때 사용됩니다.
    *   텍스트 편집기로 열면 내용을 알아보기 어렵습니다.
    *   개방 모드에 `b`를 추가하여 바이너리 모드로 개방합니다. (`"rb"`, `"wb"`, `"ab+"` 등)
    *   **Unix/Linux 시스템:** 대부분의 경우 텍스트 모드와 바이너리 모드를 구분하지 않고 모두 바이너리 파일처럼 취급합니다.

---

### `+` 개방 모드, `fseek`, `rewind`, `feof` 함수

*   **`+` 개방 모드 (`r+`, `w+`, `a+`):**
    *   파일에 대해 **읽기와 쓰기 작업을 모두** 할 수 있도록 개방합니다.
    *   **예시:** 키보드로 과일 이름을 입력받아 파일에 저장하고, 도중에 `list`를 입력하면 파일 내용을 읽어 출력하는 프로그램 구현 시 `a+` 모드를 사용할 수 있습니다. (파일이 없으면 생성, 있으면 끝에 추가, 읽기도 가능)
    *   **주의:** 파일의 **입력(읽기)과 출력(쓰기) 작업을 서로 전환**할 때마다, 일반적으로 **`fseek`, `fsetpos`, `rewind` 함수 호출**이나 **`fflush` 함수 호출**이 필요합니다. 이는 스트림 버퍼의 상태를 정리하고 위치 지시자를 올바르게 설정하기 위함입니다.
        *   예: `fprintf`로 파일에 출력한 후 바로 `fgets`로 파일 내용을 읽으려고 하면, 버퍼 상태가 꼬일 수 있으므로 중간에 `fseek` 등으로 위치를 재설정해야 합니다.

*   **`fseek()` 함수:** 파일 위치 지시자를 명시적으로 이동시킵니다.

    *   **원형:** `int fseek(FILE *stream, long offset, int whence);`
    *   **설명:** `stream` 파일의 위치 지시자를 `whence`를 기준으로 `offset`만큼 이동시킵니다.
    *   **인수:**
        *   `stream`: 파일 포인터.
        *   `offset`: 이동할 바이트 수 (`long` 타입). 양수는 파일 끝 방향, 음수는 파일 시작 방향.
        *   `whence`: 기준 위치. `stdio.h`에 정의된 매크로 상수 사용.
            | 상수명     | 값 | 설명                     | `offset` 가능 범위 |
            | :--------- | :- | :----------------------- | :----------------- |
            | `SEEK_SET` | 0  | 파일의 시작(Beginning)   | 양수만 가능        |
            | `SEEK_CUR` | 1  | 현재 위치(Current)       | 양수, 음수 모두 가능 |
            | `SEEK_END` | 2  | 파일의 끝(End)           | 음수만 가능        |
    *   **반환값:** 위치 이동 성공 시 `0`, 실패 시 `0`이 아닌 값.

*   **`rewind()` 함수:** 파일 위치 지시자를 맨 처음(파일의 시작)으로 이동시킵니다. (`fseek(fp, 0L, SEEK_SET)`과 동일한 효과)

    *   **원형:** `void rewind(FILE *stream);`

*   **`fseek` 사용 시 주의사항:**
    *   파일로부터 데이터를 모두 읽지 않은 상태에서 중간에 다시 출력(쓰기)하려면 `fseek` 함수를 호출해야 합니다.
    *   파일의 끝까지 모두 읽고 나서 쓰기로 바꾸는 경우는 호출이 필요 없을 수 있습니다(시스템에 따라 다름).
    *   **`a+` 모드:** `fseek`로 위치를 옮겨도, **쓰기 작업은 항상 파일의 맨 뒤에 추가**됩니다. 읽기 위치는 `fseek`로 조절 가능합니다.
    *   **`w+` 모드:** 읽다가 중간에 다시 쓰는 경우, `fseek`로 설정한 위치부터 **내용을 덮어씁니다.**
    *   **`r+` 모드:** 읽기와 쓰기 위치 모두 `fseek`로 조절 가능합니다. 읽기와 쓰기를 서로 바꿀 때는 `fseek` 호출이 필요합니다. 파일을 열자마자 출력하면 앞에서부터 덮어쓰고, 파일 끝까지 다 읽은 후 출력하면 바로 이어서 출력할 수 있습니다(fseek 없이).

*   **`feof()` 함수:** 파일의 끝(End Of File)에 도달했는지 여부를 확인합니다.

    *   **원형:** `int feof(FILE *stream);`
    *   **설명:** 스트림 파일의 데이터를 모두 읽었는지(파일 끝 표시자가 설정되었는지) 확인할 때 유용합니다.
    *   **반환값:**
        *   파일 끝에 도달했으면(파일 끝 표시자가 설정됨): **`0`이 아닌 값** 반환.
        *   파일 끝이 아니면: `0` 반환.
    *   **사용 시점:** `feof` 함수는 **입력 함수가 데이터 입력에 실패한 후**에 그 원인이 파일 끝 때문인지 확인하기 위해 사용합니다. 즉, **입력 함수 다음에 사용**해야 정확한 결과를 얻을 수 있습니다.
        ```c
        while (1) {
            ch = fgetc(fp);
            if (feof(fp)) { // fgetc 시도 후 파일 끝인지 확인
                break;
            }
            // 읽은 문자 ch 처리
        }
        ```

---

## 18-2. 다양한 파일 입출력 함수 (Various File I/O Functions)

---

### 한 줄씩 입출력하는 함수: `fgets`, `fputs`

*   **문자열 입력: `fgets()` 함수**

    *   **원형:** `char *fgets(char *str, int size, FILE *stream);`
    *   **설명:** 파일(`stream`)에서 데이터를 **한 줄씩** 읽어 `str` 배열에 저장합니다.
    *   **주요 기능:**
        *   공백 문자를 포함하여 한 줄 전체를 읽습니다.
        *   최대 `size - 1`개의 문자까지만 읽으므로, 할당된 버퍼(`str`)의 크기를 넘어서는 **메모리 침범(Buffer Overflow) 가능성을 차단**합니다. (매우 중요!)
        *   한 줄의 크기가 `size`보다 크면 `size - 1`개 문자만 읽고 끝에 `\0`(널 문자)를 붙여 문자열을 완성합니다.
        *   줄 끝의 **개행 문자(`\n`)까지 읽어서 버퍼에 포함**시킵니다. (단, 버퍼가 꽉 차거나 파일 끝에 도달하면 개행 문자가 없을 수도 있음)
    *   **인수:**
        *   `str`: 문자열을 저장할 배열(버퍼)의 주소.
        *   `size`: 버퍼의 전체 크기.
        *   `stream`: 입력 파일 포인터.
    *   **반환값:**
        *   성공 시: `str` (입력받은 문자열이 저장된 배열의 주소) 반환. 함수 호출 후 바로 반환값을 사용할 수 있어 편리합니다.
        *   파일의 끝에 도달했거나 오류 발생 시: `NULL` 반환.
    *   **파일 끝 검사:** `fgets`를 반복 호출하여 파일 전체를 읽을 때는 반환값이 `NULL`인지 비교하여 파일 끝을 확인해야 합니다. (`EOF`나 `-1`과 비교하지 않도록 주의!)
        ```c
        while (fgets(buffer, sizeof(buffer), fp) != NULL) {
            // buffer에 저장된 한 줄 처리
        }
        ```
    *   **개행 문자 제거:** `fgets`는 개행 문자를 포함하므로, 필요 없다면 제거해야 합니다.
        ```c
        // buffer[strlen(buffer) - 1] = '\0'; // 가장 간단하지만, 개행 문자가 없을 경우 마지막 문자를 지우는 위험 있음
        buffer[strcspn(buffer, "\n")] = '\0'; // \n 문자가 처음 나오는 위치를 찾아 \0으로 대체 (더 안전)
        ```
        **주의:** 개행 문자를 제거할 때는 파일의 마지막 줄에 개행 문자가 없는 경우를 고려해야 합니다.

*   **문자열 출력: `fputs()` 함수**

    *   **원형:** `int fputs(const char *str, FILE *stream);`
    *   **설명:** 문자열 `str`을 `stream`이 가리키는 파일에 출력합니다.
    *   **주요 기능:**
        *   문자열 끝의 널 문자(`\0`)는 출력하지 않습니다.
        *   `fgets`와 달리, **개행 문자를 자동으로 추가하지 않습니다.** 줄바꿈이 필요하면 문자열(`str`) 안에 `\n`을 포함시키거나 별도로 `fputc('\n', fp)` 등을 사용해야 합니다.
    *   **인수:**
        *   `str`: 출력할 문자열의 주소.
        *   `stream`: 출력 파일 포인터.
    *   **반환값:**
        *   성공 시: 음수가 아닌 값 (일부 시스템에서는 출력한 문자 수).
        *   실패 시: `EOF`.
    *   **`gets`/`puts`와의 비교:**
        *   `gets`: 버퍼 크기를 지정할 수 없어 메모리 침범 위험이 매우 큽니다. (사용 금지 권장)
        *   `puts`: 항상 자동으로 개행 문자를 추가하므로 문자열을 이어서 출력하기 어렵습니다.
        *   **결론:** 안전하고 정확한 파일 입출력을 위해서는 `fgets`와 `fputs` 사용을 권장합니다.

*   `fgets`/`fputs`와 표준 스트림: 이 함수들에 `stdin`과 `stdout`을 파일 포인터로 주면 키보드와 모니터로 한 줄씩 데이터를 입출력할 수 있습니다.

---

### 다양한 형태로 입출력하는 함수: `fscanf`, `fprintf`

파일 버전의 `scanf`, `printf`입니다. 파일에서 형식화된 데이터를 읽거나 파일에 형식화된 데이터를 쓸 때 사용하며, 숫자와 문자열 간의 자동 변환 기능을 제공합니다. **텍스트 파일**에 주로 사용됩니다.

*   **형식화된 입력: `fscanf()` 함수**

    *   **원형:** `int fscanf(FILE *stream, const char *format, ...);`
    *   **설명:** `stream` 파일에서 `format` 형식 문자열에 따라 데이터를 읽어, 가변 인수로 전달된 **변수의 주소**에 저장합니다. 숫자 형태의 문자열을 `int`, `double` 등의 숫자 타입 변수에 저장할 때 자동으로 변환해줍니다.
    *   **예시:** 파일에 "홍길동 100 90 80" 이라는 내용이 있을 때,
        ```c
        char name[20];
        int kor, eng, math;
        fscanf(ifp, "%s %d %d %d", name, &kor, &eng, &math);
        // name에는 "홍길동" 저장
        // kor, eng, math에는 각각 100, 90, 80이 정수로 변환되어 저장
        ```
    *   **반환값:** 성공적으로 읽어서 변수에 저장한 항목의 개수. 파일 끝에 도달하면 `EOF` 반환.

*   **형식화된 출력: `fprintf()` 함수**

    *   **원형:** `int fprintf(FILE *stream, const char *format, ...);`
    *   **설명:** 가변 인수로 전달된 값들을 `format` 형식 문자열에 따라 **문자열로 변환**하여 `stream` 파일에 출력합니다.
    *   **예시:**
        ```c
        fprintf(ofp, "Name: %s, Score: %.1f\n", name, score);
        ```
    *   **반환값:** 성공적으로 출력된 문자의 총 바이트 수. 오류 발생 시 음수 반환.

---

### 스트림 파일의 버퍼 공유 문제와 `fflush` (Buffer Issues and fflush)

*   **문제 상황:** `fscanf`와 `fgets`와 같이 버퍼를 사용하는 함수들을 혼용할 때, 특히 개행 문자 처리 방식의 차이로 인해 예상치 못한 동작이 발생할 수 있습니다.
    *   예: `fscanf`로 숫자(나이)를 읽은 후, 입력 버퍼에는 사용자가 누른 `Enter` 키에 해당하는 개행 문자(`\n`)가 남아있게 됩니다. 이어서 `fgets`로 문자열(이름)을 읽으려고 하면, `fgets`는 버퍼에 남아있는 개행 문자를 만나자마자 입력을 종료해버려 빈 문자열이 입력될 수 있습니다.
*   **해결 방법:**
    1.  **`fscanf`의 `%s` 활용 (단점 존재):** 이름을 `%s`로 읽으면 앞서 남은 개행 문자는 건너뛰지만, `%s`는 공백에서 입력을 멈추므로 "Hong Gildong" 같은 이름은 "Hong"만 입력됩니다.
    2.  **불필요한 문자 제거:** `fscanf` 호출 후 버퍼에 남은 개행 문자를 제거합니다.
        *   `fgetc(fp);` // 개행 문자 하나를 읽어서 버림 (가장 간단)
        *   `while (fgetc(fp) != '\n');` // 개행 문자가 나올 때까지 버퍼의 문자를 읽어 버림
        *   사용자 정의 함수 사용:
            ```c
            void my_fflush(FILE *fp) {
                int ch;
                while ((ch = fgetc(fp)) != '\n' && ch != EOF); // 개행 또는 EOF까지 읽어 버림
            }
            ```
    3.  **`fflush()` 함수 (출력 스트림에만 표준적으로 사용):**
        *   **원형:** `int fflush(FILE *stream);`
        *   **설명:** `stream`으로 지정된 **출력** 스트림 파일의 버퍼 내용을 강제로 해당 장치(파일)에 쓰도록 합니다.
        *   **반환값:** 성공 시 `0`, 실패 시 `EOF`.
        *   **주의:** C 표준은 `fflush`를 **출력 스트림**에 대해서만 정의합니다. **입력 스트림**(`stdin` 또는 읽기 모드 파일)에 `fflush`를 사용하는 것은 **비표준적**이며, 이식성이 떨어지고 예상대로 동작하지 않을 수 있습니다(변화 없거나 컴파일 오류 발생 가능). 입력 버퍼를 비우는 목적이라면 위 1, 2번 방법을 사용해야 합니다.
        *   출력 함수 호출 후 버퍼의 데이터를 즉시 파일에 저장하고 싶을 때 `fflush(ofp);`와 같이 사용할 수 있습니다.

---

### 바이너리 입출력 함수: `fread`, `fwrite`

데이터를 특정 형식(문자열 등)으로 변환하지 않고, 메모리에 있는 **바이트(이진) 데이터 그대로** 파일에 읽고 쓰는 함수입니다. 구조체, 배열 등 복잡하거나 큰 데이터를 파일에 저장하고 읽을 때 효율적입니다. **바이너리 파일**에 주로 사용됩니다.

*   **바이너리 쓰기: `fwrite()` 함수**

    *   **원형:** `size_t fwrite(const void *ptr, size_t size, size_t count, FILE *stream);`
    *   **설명:** `ptr`이 가리키는 메모리에서, `size` 바이트 크기의 데이터 항목을 `count`개 만큼 읽어서 `stream` 파일에 **바이너리 형태 그대로** 씁니다. (총 `size * count` 바이트 출력)
    *   **인수:**
        *   `ptr`: 출력할 데이터가 저장된 메모리의 시작 주소.
        *   `size`: 데이터 항목 하나의 크기 (바이트 단위). (`sizeof()` 연산자 활용)
        *   `count`: 출력할 데이터 항목의 개수.
        *   `stream`: 출력 파일 포인터 (반드시 **바이너리 모드 `b`**로 열어야 함).
    *   **반환값:** 성공적으로 출력된 데이터 **항목의 개수** (`count`와 같아야 정상).
    *   **예시:**
        ```c
        int num = 10; // 메모리에 4바이트(가정) 이진수로 저장됨
        fwrite(&num, sizeof(num), 1, bfp); // num 변수의 내용을 그대로 파일에 씀
        ```
    *   **`fprintf`와의 차이:** `fprintf(bfp, "%d", num);`은 `num`의 값 10을 문자 '1'과 '0'의 아스키 코드로 변환하여 파일에 쓰지만, `fwrite`는 `num` 변수의 메모리상 이진 표현(예: `0x0000000A`)을 그대로 파일에 씁니다. 따라서 `fwrite`로 쓴 파일은 텍스트 편집기로 내용을 알아보기 어렵습니다.

*   **바이너리 읽기: `fread()` 함수**

    *   **원형:** `size_t fread(void *ptr, size_t size, size_t count, FILE *stream);`
    *   **설명:** `stream` 파일에서 `size` 바이트 크기의 데이터 항목을 `count`개 만큼 읽어서 `ptr`이 가리키는 메모리에 **바이너리 형태 그대로** 저장합니다.
    *   **인수:**
        *   `ptr`: 읽어 들인 데이터를 저장할 메모리의 시작 주소.
        *   `size`: 데이터 항목 하나의 크기.
        *   `count`: 읽어 들일 데이터 항목의 개수.
        *   `stream`: 입력 파일 포인터 (반드시 **바이너리 모드 `b`**로 열어야 함).
    *   **반환값:** 성공적으로 읽어 들인 데이터 **항목의 개수**. 파일 끝에 도달하면 요청한 `count`보다 작을 수 있습니다.

*   **핵심:** `fread`와 `fwrite` 함수는 숫자와 문자 사이의 변환 과정을 수행하지 않아 입출력 효율이 높습니다. 데이터를 있는 그대로 입출력하므로 파일은 반드시 **바이너리 모드(`b`)**로 개방해야 합니다.
```
