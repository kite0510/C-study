# Chapter 14. 다차원 배열과 포인터 배열

## 2차원 배열

---

### 2차원 배열의 선언과 요소 사용

*   **선언:** `int score[3][4];`
    *   `3`: 행(row)의 수
    *   `4`: 열(column)의 수
    *   `int`: 각 요소의 자료형 (이 경우 `int`형 변수 12개가 생성됨)
*   **인덱스:**
    *   행과 열 모두 0부터 시작합니다.
    *   최대 인덱스는 (행의 수 - 1), (열의 수 - 1)입니다.
*   **메모리 할당:**
    *   **논리적:** 행렬(matrix) 구조 (2차원)
    *   **물리적:** 1차원 배열 형태로 메모리에 *연속적*으로 할당됩니다.  한 행씩 차례대로 할당됩니다. (row-major order)

---

### 2차원 배열의 초기화

*   **기본 초기화:**
    ```c
    int num[3][4] = {
        {1, 2, 3, 4},
        {5, 6, 7, 8},
        {9, 10, 11, 12}
    };
    ```

*   **부분 초기화:**
    *   초기값이 부족하면, 각 행의 앞에서부터 채워지고 남는 요소는 `0`으로 자동 초기화됩니다.
    ```c
    int num[3][4] = {
        {1, 2},       // 1, 2, 0, 0
        {5, 6, 7},    // 5, 6, 7, 0
        {9}          // 9, 0, 0, 0
    };

    ```

*   **행의 수 생략:**
    *   컴파일러가 초기화 리스트의 중괄호 개수를 보고 행의 수를 결정합니다.
    *   *열의 수는 반드시 명시해야 합니다.* (각 행의 크기를 알아야 하기 때문)

    ```c
    int num[][4] = {  // 행의 수 자동 결정 (3)
        {1, 2, 3, 4},
        {5, 6, 7, 8},
        {9, 10, 11, 12}
    };
    ```

*   **행 초기화 괄호 생략:**
    *   초기값들이 행 단위로 차례대로 저장됩니다.
    *   초기값이 부족하면 남는 요소는 `0`으로 초기화됩니다.

    ```c
    int num[3][4] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}; // 모든 요소 초기화
    int num2[3][4] = {1, 2, 3, 4, 5}; // 1, 2, 3, 4, 5, 0, 0, 0, 0, 0, 0, 0
    ```
*   **행의 수와 행 초기화 괄호 모두 생략:**
    ```c
    int num[][4] = {1,2,3,4,5,6}; // 행의 수: 2, 각 행은 {1,2,3,4}, {5,6,0,0}
    ```
    *   열의 수에 맞게 초기값을 끊어서 행의 수를 결정합니다.

*   **2차원 배열의 본질:** 2차원 배열은 *1차원 배열을 요소로 갖는 1차원 배열*입니다.
    *   `num` 배열은 `num[0]`, `num[1]`, `num[2]`라는 부분 배열(1차원 배열)을 가집니다.
    *   `sizeof(num)`: 전체 배열의 크기
    *   `sizeof(num[0])`: 한 행의 크기 (부분 배열의 크기)
    *   `행의 수 = sizeof(num) / sizeof(num[0])`

---

### 2차원 `char` 배열

*   **용도:** 여러 개의 문자열을 저장하고 처리할 때 사용합니다.
*   **각 행:** 하나의 1차원 `char` 배열 (문자열)입니다.
*   **부분 배열명:** 각 행의 배열명 역할을 합니다.
*   **문자열 입력:**
    ```c
    char animal[3][20]; // 3개의 문자열 저장 (각 문자열 최대 19자 + '\0')
    scanf("%s", animal[0]); // 첫 번째 행에 문자열 입력.  animal[0]은 배열명이므로 & 필요 없음
    scanf("%s", animal[1]);
    scanf("%s", animal[2]);
    ```

*   **2차원 `char` 배열 초기화:**
    1.  **배열 요소별 초기화:** (다른 2차원 배열과 동일)
        ```c
        char animal[3][10] = {
            {'c', 'a', 't', '\0'},
            {'d', 'o', 'g', '\0'},
            {'b', 'i', 'r', 'd', '\0'}
        };
        ```
    2.  **문자열 단위 초기화:** (더 편리하고 가독성이 좋음)
        ```c
        char animal[3][10] = {
            "cat",
            "dog",
            "bird"
        };
        ```

---

## 3차원 배열

*   **개념:** 3차원 배열은 *2차원 배열을 요소로 갖는 배열*입니다.
*   **선언:** `int score[2][3][4];`
    *   `2`: 면(plane)의 수
    *   `3`: 행(row)의 수
    *   `4`: 열(column)의 수
    *   `int`: 요소의 자료형
*   **부분 배열:**
    *   `score[0]`, `score[1]`: 면 부분 배열 (2차원 배열)
    *   각 면 부분 배열은 3개의 행 부분 배열(1차원 배열)을 가집니다.
*   **인덱스:** 면, 행, 열 순서로 3개의 인덱스를 사용합니다.
*   **초기화:** 3중 중괄호를 사용합니다.
*   **요소 접근:** 3중 `for` 루프를 사용하는 것이 일반적입니다.

---

## 포인터 배열

---

### 포인터 배열의 선언과 사용

*   **포인터 배열:** 포인터(주소)를 저장하는 배열입니다.
*   **선언:** `int *pary[3];`
    *   `int *`: 각 배열 요소의 자료형이 `int`형 포인터임을 나타냅니다.
    *   `[3]`: 배열의 크기 (3개의 포인터를 저장)

*   **문자열 상수와 포인터 배열:**
    ```c
    char *pary[3] = {"apple", "banana", "orange"}; // 문자열 리터럴(상수)의 주소 저장
    ```
    *   문자열 상수는 변경 불가능한 메모리 영역에 저장됩니다.
    *   포인터 배열의 각 요소에는 문자열 상수의 *첫 번째 문자*의 주소가 저장됩니다.
    *   문자열 상수들은 메모리에 개별적으로 존재하므로, 포인터 배열의 요소에 저장된 주소 값들은 연속적이지 않을 수 있습니다.

*   **`char` 포인터 배열 초기화:** 2차원 `char` 배열 초기화와 *유사한 방식*으로 초기화할 수 있습니다.

    ```c
    char *pary[3] = {"apple", "banana", "orange"}; // 포인터 배열: 문자열 시작 주소 저장
    char ary2[3][10] = {"apple", "banana", "orange"}; // 2차원 char 배열: 문자열 자체 저장
    ```
     *   **차이점**: 포인터 배열은 *문자열의 시작 주소만* 저장, 2차원 `char` 배열은 *문자열 자체를* 배열 공간에 저장.

---

### 2차원 배열처럼 활용하는 포인터 배열

```c
int ary1[4] = {1, 2, 3, 4};
int ary2[4] = {11, 12, 13, 14};
int ary3[4] = {21, 22, 23, 24};

int *pary[3] = {ary1, ary2, ary3}; // 각 1차원 배열의 배열명을 포인터 배열에 초기화

// pary[i][j] 형태로 2차원 배열처럼 접근 가능
printf("%d\n", pary[1][2]); // 13 (ary2[2]와 동일)
```
*   **`int *pary[3] = {ary1, ary2, ary3};` 상세 설명:**

    ```c
    int *pary[3];
    ```
    *   `int *pary[3];` : `int`형 포인터 3개를 저장할 수 있는 포인터 배열 `pary`를 선언합니다.

        *   `int *`:  배열 요소의 타입이 `int`형 포인터(주소)임을 나타냅니다.
        *   `pary`:  포인터 배열의 이름입니다.
        *   `[3]`:  배열의 크기가 3임을 나타냅니다. (3개의 `int`형 포인터를 저장할 수 있습니다.)
        *  각 요소는 int형 변수 또는 int형 배열의 주소를 저장할 수 있습니다.

    ```c
     {ary1, ary2, ary3}
    ```

    *   `{ary1, ary2, ary3}`: 포인터 배열 `pary`를 초기화하는 초기화 리스트입니다.

        *    `ary1`, `ary2`, `ary3`는 각각 `int`형 1차원 배열의 이름입니다.
        *    C 언어에서 배열의 이름은 해당 배열의 *첫 번째 요소의 주소*를 나타내는 *주소 상수*입니다.
        *   따라서:
            *   `pary[0]`에는 `ary1`의 첫 번째 요소의 주소가 저장됩니다.
            *   `pary[1]`에는 `ary2`의 첫 번째 요소의 주소가 저장됩니다.
            *   `pary[2]`에는 `ary3`의 첫 번째 요소의 주소가 저장됩니다.
---

### **`pary[2][2]`를 포인터 표현으로 변환하는 과정 및 의미**

가정:
*   `pary[2]`에는 `ary3` 배열의 시작 주소(예: 300)가 저장되어 있다고 가정합니다.
*   `int` 자료형의 크기는 4바이트라고 가정합니다.

1.  **배열 표현:** `pary[2][2]`

2.  **1단계: 내부 `[]` 연산자를 포인터 연산으로 변환**

    `pary[2][2]`  =>  `*(pary[2] + 2)`

    *   `pary[2]`는 `pary`의 세 번째 요소에 저장된 값, 즉 `ary3`의 시작 주소를 나타냅니다.
    *   `pary[2] + 2`는 `ary3` 배열의 시작 주소에서 2만큼 떨어진 요소의 주소를 계산하는 포인터 연산입니다.
    *   `*(pary[2] + 2)`는 그 주소에 있는 값을 가져오는 간접 참조 연산입니다.

3.  **2단계: `pary[2]`의 값 대입 (가정)**

    `*(pary[2] + 2)`  =>  `*(300 + 2)`  (∵ `pary[2]`에 300이 저장되어 있다고 가정)

4.  **3단계: 포인터 연산 수행**

   `*(300 + 2)` 에서 덧셈은 단순한 정수 덧셈이 아니라 *포인터 연산*입니다. 포인터 연산에서 `+`는 다음과 같이 동작합니다.
    ```
    주소 + 정수  =>  주소 + (정수 * 가리키는 자료형의 크기)
    ```

   `pary[2]`는 `int`형 변수를 가리키는 포인터이므로, `int`형의 크기(4바이트)를 곱합니다.

    `*(300 + 2)`  => `*(300 + (2 * sizeof(int)))` => `*(300 + (2 * 4))` => `*(300 + 8)` => `*(308)`

5.  **4단계: 간접 참조**

    `*(308)`

    *   `308`은 `ary3` 배열의 세 번째 요소(`ary3[2]`)의 주소입니다. (가정)
    *   `*` (간접 참조 연산자)는 주소 `308`에 저장된 값을 가져옵니다.
    *   `ary3[2]`에 23이 저장되어 있었다면, `*(308)`은 23이 됩니다.

**결론:**

`pary[2][2]`는 포인터 연산을 통해 `*(308)`로 변환되며, 최종적으로 `ary3` 배열의 세 번째 요소의 값(예: 23)을 나타냅니다.

**핵심:**

*   2차원 배열(또는 포인터 배열을 2차원 배열처럼 사용하는 경우)의 `[][]` 연산자는 내부적으로 포인터 연산으로 변환됩니다.
*   포인터 연산에서 `+`는 단순한 덧셈이 아니라, 가리키는 자료형의 크기를 고려하여 주소를 계산합니다.
*   `*` (간접 참조 연산자)는 해당 주소에 저장된 값을 가져옵니다.
