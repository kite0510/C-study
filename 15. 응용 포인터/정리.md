# Chapter 15. 응용 포인터

### 이중 포인터 개념

*   **포인터:** 변수(메모리 공간)의 주소를 저장하는 변수입니다.
*   **이중 포인터:** *포인터 변수의 주소*를 저장하는 변수입니다. (포인터를 가리키는 포인터)
*   **선언:**
    ```c
    int a = 10;
    int *pi = &a;       // pi는 a를 가리킴 (int형 포인터)
    int **ppi = &pi;    // ppi는 pi를 가리킴 (int형 이중 포인터)
    ```
    *   `**`: 별 두 개를 사용하여 이중 포인터임을 나타냅니다.
    *   첫 번째 `*`: 가리키는 변수의 자료형(`int *`)
    *   두 번째 `*`: 이중 포인터 자신의 자료형(`int **`)

*   **포인터 연산 규칙:**

    1.  **포인터 변수명:** 포인터 변수에 저장된 *값(주소)*을 의미합니다.
    2.  **`&` 연산자:** 포인터 변수의 *주소*를 구합니다.
    3.  **`*` 연산자 (간접 참조):**
        *   `*pi`: `pi`가 가리키는 곳의 *값* (`a`의 값)
        *   `*ppi`: `ppi`가 가리키는 곳의 *값* (`pi`의 값, 즉 `a`의 주소)
        *   `**ppi`: `ppi`가 가리키는 곳(`pi`)이 가리키는 곳의 *값* (`a`의 값)

    ```
      ppi  --->  pi  --->  a
     **ppi      *pi       a (값)
     &ppi       &pi     &a
    ```

---

### 이중 포인터의 형태

*   **포인터의 형태:**  `자료형 *` (예: `int *`, `double *`)
*   **이중 포인터의 형태:** `자료형 **` (예: `int **`, `double **`)
*   **핵심:** 포인터를 선언할 때는, *저장할 주소가 어떤 포인터 형의 주소인지*를 먼저 파악해야 합니다.
*   `double *pd;`에서 `double`은 `pd`가 가리키는 변수의 자료형을 나타낼 뿐, `pd` 자체의 자료형은 `double *` 입니다.

---

### 주소와 포인터의 차이

| 구분     | 주소                                   | 포인터                                      |
| -------- | -------------------------------------- | ------------------------------------------- |
| 종류     | 상수 (constant)                           | 변수 (variable)                             |
| 값 변경  | 불가능                                  | 가능                                       |
| 주소 연산 | 불가능 (`&(&a)`는 오류)                 | 가능 (`&pi`는 `pi`의 주소)                   |
| 저장     | 별도의 저장 공간을 가지지 않음(일반적인 경우) | 메모리에 저장 공간을 가짐(변수이므로)        |
| L-value  | 될 수 없음 (왼쪽에 올 수 없음)         | 될 수 있음 (왼쪽, 오른쪽에 모두 올 수 있음) |

---

### 다중 포인터

*   이중 포인터도 변수이므로 주소 연산자(`&`)를 사용하여 그 주소를 구할 수 있습니다.
*   이중 포인터의 주소를 저장하는 변수를 *삼중 포인터*라고 합니다.
*   **선언:** `double ***ppp;` ( `ppp`는 `double **`형 변수의 주소를 저장)
    *   `***`: 별 세 개를 사용하여 삼중 포인터임을 나타냅니다.

---

### 이중 포인터 활용

1.  **포인터 값을 바꾸는 함수의 매개변수:**

    ```c
    void swap_ptr(char **ppa, char **ppb) {
        char *temp;
        temp = *ppa;
        *ppa = *ppb;
        *ppb = temp;
    }
    ```
    *   `ppa`와 `ppb`는 `char *`형 변수(문자열의 시작 주소를 저장하는 포인터)의 주소를 받습니다.
    *   `*ppa`와 `*ppb`를 통해 원래의 포인터 변수(`pa`, `pb` 등)에 접근하여 그 값을 교환합니다.

2.  **포인터 배열을 매개변수로 받는 함수:**

   ```c
   void print_str(char **ptr_ary, int count){
      int i;
      for(int i = 0; i < count; i++){
         printf("%s\n", ptr_ary[i]);
      }
   }
   ```

    *   `char *ptr_ary[]`: `char`형 포인터 배열. 각 요소는 문자열의 시작 주소를 저장합니다.
    *   `ptr_ary`: 포인터 배열의 이름은 배열의 첫 번째 요소(포인터)의 주소입니다. 즉 `char **` 타입입니다.
    *   `print_str` 함수의 매개변수 `ptr_ary`는 `char **` (이중 포인터)로 선언되어, 포인터 배열의 이름을 인수로 받을 수 있습니다.

---

### 배열 요소의 주소와 배열의 주소

*   `int ary[5];`

    *   `ary`: 배열의 이름. 배열의 첫 번째 요소의 주소로 사용됩니다. (`&ary[0]`과 같음)
    *   `&ary`: 배열 *전체*의 주소.
    *   `sizeof(ary)` : 배열 전체의 크기.
    *   `sizeof(&ary)` : 주소의 크기(4 or 8 bytes).
*   **값은 같지만 의미(가리키는 대상)가 다름:**

    *   `ary + 1`: `ary[0]`의 주소 + `sizeof(int)` (4바이트)
    *   `&ary + 1`: `ary`의 주소 + `sizeof(ary)` (20바이트, 배열 전체 크기)
    * 즉 ary+1은 두번째 배열요소를 가리키고, &ary + 1은 배열 전체 바로 다음 주소를 가리킨다.

*   **규칙:**

    1.  배열은 전체가 하나의 논리적인 변수입니다. (`sizeof(ary)`, `&ary` 사용 가능. 단, 대입 연산자 왼쪽에는 올 수 없음.)
    2.  배열의 주소에 정수를 더하면, 배열 *전체*의 크기를 곱해서 더합니다.

---

### 2차원 배열과 배열 포인터

*   **2차원 배열의 이름:** 1차원 배열(부분 배열)의 주소입니다.
*   **배열 포인터:** 배열을 가리키는 포인터입니다.

    ```c
    int ary[3][4];
    int (*pa)[4]; // pa는 크기가 4인 int형 배열을 가리키는 포인터

    pa = ary;     // pa에 2차원 배열 ary의 이름(첫 번째 부분 배열의 주소)을 저장
    pa[i][j] = 10; // pa를 2차원 배열처럼 사용 가능
    ```

    *   `int (*pa)[4];`
        *   `pa`: 포인터 변수의 이름
        *   `(*pa)`: `pa`가 포인터임을 나타냅니다. (괄호 필수)
        *   `[4]`: `pa`가 가리키는 것이 크기가 4인 배열임을 나타냅니다.
        *   `int`: 배열 요소의 자료형이 `int`임을 나타냅니다.

---

### 2차원 배열 요소의 2가지 의미

*   **논리적 요소:** 1차원의 부분 배열 (행)
*   **물리적 요소:** 실제 데이터를 저장하는 부분 배열의 개별 요소 (각 칸)

---

### 2차원 배열의 요소를 참조하는 원리

`int ary[3][4];` (값이 1~12로 초기화되었다고 가정)에서 일곱 번째 물리적 요소(`ary[1][2]`)를 참조하는 과정:

1.  **`ary[1]`의 시작 위치 구하기:**

    *   `ary`: 첫 번째 부분 배열(`ary[0]`)의 주소.
    *   `ary + 1`: 두 번째 부분 배열(`ary[1]`)의 주소.
        ```
        ary + 1  =>  ary의 주소 + (1 * sizeof(ary[0]))
                 =>  ary의 주소 + (1 * 16)  // ary[0]은 크기가 4인 int 배열
        ```

2.  **`ary[1]`을 주소로 사용:**

    *   `*(ary + 1)`은 `ary[1]`과 같습니다.  `ary[1]`은 두 번째 부분 배열의 *첫 번째 요소의 주소*로 사용될 수 있습니다.

3.  **일곱 번째 요소의 주소 계산:**

    ```
    *(ary + 1) + 2  =>  ary[1]의 주소 + (2 * sizeof(int))
                    =>  ary[1]의 주소 + (2 * 4)
    ```

4.  **간접 참조:**
    ```
     *(*(ary + 1) + 2)  =>  ary[1][2]
    ```

    *    `*(*(ary + 1) + 2)`: `ary[1]`의 시작 주소에서 2만큼 떨어진 요소의 *값*을 가져옵니다 (일곱 번째 물리적 요소의 값).

**결론:** 2차원 배열의 이름(`ary`)을 사용하여 배열의 모든 요소에 접근할 수 있습니다.  배열 포인터에 2차원 배열의 이름을 저장하면, 배열 포인터를 2차원 배열처럼 사용할 수 있습니다.

**2차원 배열 관련 주소 표현:**
| 표현          | 의미                                   | 타입             | sizeof 결과(예) |
| ------------- | -------------------------------------- | --------------- | --------------- |
| `&ary`        | 2차원 배열 *전체*의 주소              | `int (*)[3][4]` | 4 또는 8        |
| `ary`         | 첫 번째 부분 배열(`ary[0]`)의 주소        | `int (*)[4]`    | 4 또는 8        |
| `&ary[0]`     | 첫 번째 부분 배열(`ary[0]`)의 주소        | `int (*)[4]`    | 4 또는 8        |
| `ary[0]`      | 첫 번째 부분 배열의 첫 번째 요소의 주소     | `int *`        | 4 또는 8        |
| `&ary[0][0]`  | 첫 번째 부분 배열의 첫 번째 요소의 주소     | `int *`        | 4 또는 8        |
|`sizeof(ary)`| 2차원 배열 전체의 크기 | | 48 |
|`sizeof(&ary[0])`| 주소의 크기|  | 4/8|
|`sizeof(ary[0])` | 부분배열 전체의 크기|  | 16 |
|`sizeof(&ary[0][0])` | 주소의 크기 |  |4/8|

---

### 함수 포인터의 개념

*   **함수명:** 함수의 정의(코드)가 저장된 메모리의 *시작 주소*입니다. (주소 상수)
*   **함수 포인터:** 함수명을 저장할 수 있는 변수입니다.
*   **함수의 형태:** 매개변수의 개수와 자료형, 반환값의 자료형으로 정의됩니다.

    ```c
    int sum(int a, int b); // 함수의 원형(prototype)

    int (*fp)(int, int); // 함수 포인터 선언

    fp = sum;    // 함수 포인터에 함수명을 저장

    int result = fp(10, 20);  // 함수 포인터를 사용하여 함수 호출 (sum(10, 20)과 동일)
    int result = (*fp)(10,20);
    ```
    *   `int (*fp)(int, int);`
        * `fp`: 함수 포인터의 이름입니다.
        * `(*fp)`: `fp`가 포인터임을 나타냅니다. (괄호 필수)
        * `(int, int)`: `fp`가 가리키는 함수가 `int`형 매개변수 두 개를 받는다는 것을 나타냅니다.
        * `int`: `fp`가 가리키는 함수의 반환형이 `int`임을 나타냅니다.

---

### 함수 포인터의 활용

*   함수의 형태(매개변수, 반환형)만 같으면, 기능과 상관없이 모든 함수에 함수 포인터를 사용할 수 있습니다.
*   함수 포인터를 함수의 매개변수로 사용하여, 함수 내부에서 다양한 함수를 호출할 수 있습니다. (콜백 함수 구현 등에 활용)

    ```c
    void execute_operation(int a, int b, int (*operation)(int, int)) {
       int result = operation(a, b);
        printf("Result: %d\n", result);
    }

    // execute_operation(10, 5, sum);      // 덧셈
    // execute_operation(10, 5, subtract); // 뺄셈
    ```

---

### `void` 포인터

*   **`void` 포인터:** 가리키는 자료형이 정해지지 않은 포인터입니다.
*   **선언:** `void *vp;`
*   **특징:**
    *   어떤 자료형의 주소든 저장할 수 있습니다. (범용 포인터)
    *   `*` (간접 참조) 연산이나 `+`, `-` 등의 포인터 연산을 직접 수행할 수 *없습니다*. (가리키는 자료형을 모르기 때문)
    *   사용하기 전에 반드시 *명시적 형 변환*을 해야 합니다.

    ```c
    int a = 10;
    double b = 3.14;
    void *vp;

    vp = &a;
    printf("%d\n", *(int *)vp); // int *로 형 변환 후 간접 참조

    vp = &b;
    printf("%.2lf\n", *(double *)vp); // double *로 형 변환 후 간접 참조
    ```

    *   `*(int *)vp`:
        1.  `vp`를 `int *` 형으로 변환합니다. (`vp`가 `int`형 변수의 주소를 저장하고 있다고 알려줌)
        2.  `*` (간접 참조 연산자)를 사용하여 `int`형 변수의 값을 가져옵니다.
        3. 형변환 할 때에는 오른쪽에서 왼쪽으로 차례로 연산한다.
```


