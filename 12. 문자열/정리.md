# Chapter 12. 문자열

## 문자열 상수 구현 방법

*   **문자열 상수의 저장:** 컴파일러는 문자열 상수(예: `"apple"`)를 `char` 배열 형태로 별도의 메모리 영역(읽기 전용)에 저장합니다.
*   **주소로 대체:** 코드 내에서 문자열 상수가 사용된 곳에는 해당 문자열이 저장된 메모리 영역의 *시작 주소*가 사용됩니다.
*   **변경 불가:** 문자열 상수는 읽기 전용 메모리에 저장되므로, 주소를 통해 값을 변경하려고 하면(`*"apple" = 't';`) 운영체제에 의해 제한됩니다. (Segmentation fault, undefined behavior)
*    **NULL문자**: 컴파일러는 문자열 상수를 저장할 때 항상 마지막에 널 문자('\0')를 추가한다.

---

## `char` 포인터로 문자열 사용

*   **문자열은 주소:** 문자열은 결국 메모리 상의 주소입니다.
*   **`char` 포인터에 대입:** 문자열(문자열 상수의 주소)을 `char` 포인터 변수에 대입하면, 해당 포인터를 통해 문자열을 사용할 수 있습니다.
    ```c
    char *dessert = "apple"; // dessert는 "apple" 문자열의 시작 주소를 가리킴
    ```
*   **포인터 연산 활용:**
    *   `dessert + i`: 문자열 내에서 `i`번째 문자의 주소를 얻습니다.
    *   `*(dessert + i)`: `i`번째 문자의 값을 얻습니다. (`dessert[i]`와 동일)
    *   포인터 값을 증가시키면서 널 문자(`\0`)를 만날 때까지 반복하면 문자열 전체를 처리할 수 있습니다.

    ```c
    // printf("%s", dessert); 와 동일한 동작
    while (*dessert != '\0') {
        putchar(*dessert);
        dessert++;
    }
    ```
*   **문자열 상수 공유 (최적화):** 컴파일러는 동일한 문자열 상수가 여러 번 사용될 경우, 메모리에 하나의 문자열만 저장하고 그 주소를 공유합니다. (메모리 절약)

---

## `scanf` 함수를 사용한 문자열 입력

*   **`%s` 변환 문자:** `scanf("%s", str);`는 공백, 탭, 개행 문자를 만나기 전까지의 연속된 문자열을 입력받아 `str` 배열에 저장합니다.
*   **버퍼 사용:** 키보드 입력은 버퍼에 저장되었다가 `scanf` 함수에 의해 처리됩니다.
*   **입력 제한:** 공백, 탭, 개행 문자를 만나면 그 이전까지만 입력으로 처리하고, 나머지 입력은 버퍼에 남겨둡니다.
*   **주의:** 배열의 크기를 벗어나는 입력을 받으면 *버퍼 오버플로우*가 발생할 수 있습니다.

---

## `gets` 함수를 사용한 문자열 입력

*   **`gets(str);`:**  개행 문자(`\n`)를 만날 때까지 한 줄 전체(공백, 탭 포함)를 입력받아 `str` 배열에 저장합니다.
*   **개행 문자의 처리:** 버퍼에 있는 개행 문자는 널 문자(`\0`)로 바뀌어 배열에 저장됩니다.
*   **위험성:**  입력받을 배열의 크기를 검사하지 않으므로, *버퍼 오버플로우*가 발생할 *위험이 매우 큽니다*.  (사용하지 않는 것이 좋습니다.)

---

## `fgets` 함수를 사용한 문자열 입력 (안전)

*   **`fgets(str, size, stdin);`:**  최대 `size - 1`개의 문자를 입력받아 `str` 배열에 저장합니다.
    *   `stdin`: 표준 입력(키보드)을 나타냅니다. (`fgets`는 파일에서도 입력을 받을 수 있음)
    *   개행 문자(`\n`)도 입력에 포함됩니다.
*   **버퍼 오버플로우 방지:**  입력받을 최대 크기를 지정하므로 버퍼 오버플로우를 방지할 수 있습니다.
*   **개행 문자 제거:**  보통 `fgets`로 입력받은 문자열의 마지막에는 개행 문자가 포함되므로, 필요에 따라 제거해야 합니다.
    ```c
    str[strlen(str) - 1] = '\0'; // 마지막 문자를 널 문자로
    ```
    * `strlen(str)`은 문자열의 길이(널 문자 제외)를 반환. string.h에 정의되어있음.

---

## 표준 입력 함수의 버퍼 공유 문제

*   **문제 상황:** `scanf`, `getchar`, `gets`, `fgets` 등은 표준 입력 버퍼를 공유합니다.  이전에 호출된 함수가 버퍼에 개행 문자를 남겨두면, 다음에 호출되는 함수가 이 개행 문자를 즉시 읽어들이고 입력을 종료하는 문제가 발생할 수 있습니다.
    ```c
    int age;
    char name[80];
    scanf("%d", &age); // 숫자 입력 후 개행 문자가 버퍼에 남음
    gets(name);       // gets는 버퍼에 남아있는 개행 문자만 읽고 바로 종료됨
    ```
*   **해결 방법:** 버퍼를 비워주어야 합니다.
    *   `getchar();`:  버퍼에서 하나의 문자를 읽고 버립니다. (간단하지만, 버퍼에 여러 문자가 남아있을 수 있음)
    *   `scanf("%*c");`:  버퍼에서 하나의 문자를 읽고 버립니다. (변수 필요 없음)
    *   `fgetc(stdin);`: 표준 입력 버퍼에서 하나의 문자를 읽고 버립니다.

## `puts`와 `fputs` 함수 (문자열 출력)

*   **`puts(str);`:**  문자열 `str`을 출력하고 *자동으로 줄 바꿈*을 합니다.
*   **`fputs(str, stdout);`:**  문자열 `str`을 출력하고 *줄 바꿈을 하지 않습니다*.
    *   `stdout`: 표준 출력(화면)을 나타냅니다. (`fputs`는 파일에도 출력할 수 있음)
*   **반환 값:** 성공하면 0, 실패하면 -1 (EOF)을 반환합니다.

---

## 핵심 요약

*   문자열은 메모리에 저장된 문자들의 연속이며, 문자열 상수는 읽기 전용 메모리에 저장됩니다.
*   `char` 포인터를 사용하여 문자열을 조작할 수 있습니다.
*   `scanf`, `gets`, `fgets`를 사용하여 문자열을 입력받을 수 있으며, `fgets`가 가장 안전합니다.
*   표준 입력 함수들은 버퍼를 공유하므로, 주의해서 사용해야 합니다.
*    `puts`와 `fputs`를 사용하여 문자열을 출력할 수 있습니다.
*   `string.h` 헤더 파일에는 문자열 처리에 유용한 함수들(`strlen`, `strcpy`, `strcmp`, `strcat` 등)이 정의되어 있습니다. (이 내용은 챕터 12 이후에 나올 가능성이 큽니다.)

```c
// 예제 코드 (위의 내용을 포함하는 간략한 예제)
#include <stdio.h>
#include <string.h>

int main() {
  char str[100];

  // fgets를 사용한 안전한 문자열 입력 및 개행 문자 제거
    printf("문자열을 입력하세요: ");
    fgets(str, sizeof(str), stdin);
    str[strlen(str) - 1] = '\0';

    // puts를 사용한 출력
    puts(str);

    return 0;
}
```
# 문자열 연산 함수
 C 언어에서 문자열을 다루는 데 유용한 표준 라이브러리 함수들을 살펴봅니다.  `string.h` 헤더 파일에 선언되어 있습니다.

---

## 문자열을 대입하는 `strcpy` 함수

*   **기능:** 문자열을 복사하여 다른 배열에 대입합니다.
*   **원형:** `char *strcpy(char *dest, const char *src);`
    *   `dest`: 복사 *받을* 배열의 시작 주소 (destination)
    *   `src`: 복사 *할* 문자열의 시작 주소 (source)
    *   반환 값: `dest` (복사받은 배열의 시작 주소)
*   **동작:** `src` 문자열의 첫 번째 문자부터 널 문자(`\0`)를 만날 때까지 모든 문자를 `dest` 배열에 순서대로 복사합니다.  복사 후 `dest`의 끝에 널 문자를 추가합니다.
*   **`src` 인수의 조건:**  `char` 배열명, 문자열 상수의 주소, 문자열의 시작 주소를 저장한 포인터 등, 문자열의 시작 주소를 나타내는 어떤 것이든 가능합니다.
*   **`dest` 인수의 조건:** `char` 배열 또는 `char` 배열명을 저장한 포인터만 가능합니다. (문자열 상수는 읽기 전용이므로 복사받을 수 없음)
* **주의:** `dest` 배열의 크기가 `src` 문자열의 길이보다 작으면 *버퍼 오버플로우*가 발생할 수 있습니다.

```c
char str1[80];
strcpy(str1, "hello"); // str1에 "hello" 복사
```
---

## 원하는 개수의 문자만 복사하는 `strncpy` 함수

*   **기능:** 지정된 개수만큼의 문자만 복사합니다.
*   **원형:** `char *strncpy(char *dest, const char *src, size_t n);`
    *   `dest`: 복사 *받을* 배열의 시작 주소 (destination)
    *   `src`: 복사 *할* 문자열의 시작 주소 (source)
    *   `n`: 복사할 문자의 개수
    *   반환 값: `dest` (복사받은 배열의 시작 주소)
*   **동작:** `src` 문자열에서 최대 `n`개의 문자를 `dest`에 복사합니다.
    *   `src`의 길이가 `n`보다 작으면, 나머지 부분을 널 문자(`\0`)로 채웁니다.
    *   `src`의 길이가 `n`보다 크거나 같으면, `dest`에 널 문자가 추가되지 *않을 수 있습니다*.  이 경우, `dest` 끝에 직접 널 문자를 추가해야 안전합니다.
*   **주의:** `strncpy`는 `n`이 `src`의 길이보다 크거나 같을 때 널 문자를 자동으로 추가해주지 *않을 수 있으므로*, `strcpy`보다 *안전하다고 할 수 없습니다*. 항상 복사 후 널 문자를 수동으로 추가하는 것이 좋습니다.

```c
char str2[80];
strncpy(str2, "apple-pie", 5); // str2에 "apple" 복사
str2[5] = '\0';             // 널 문자 수동 추가 (안전)
```
---

## 문자열을 붙이는 `strcat` 함수

*   **기능:** 한 문자열의 끝에 다른 문자열을 이어 붙입니다.
*   **원형:** `char *strcat(char *dest, const char *src);`
    *   `dest`: 이어 붙여질 배열의 시작 주소
    *   `src`: 이어 붙일 문자열의 시작 주소
    *   반환값: `dest`(이어 붙여진 배열의 시작 주소)
*   **동작:** `dest` 문자열의 끝(널 문자)을 찾은 후, 그 위치부터 `src` 문자열을 복사하여 붙여넣습니다.  붙여넣기가 끝난 후 널 문자를 추가합니다.
*   **주의:** `dest` 배열의 크기가 충분히 커야 합니다.  그렇지 않으면 *버퍼 오버플로우*가 발생할 수 있습니다.
*   **초기화:** `strcat` 함수는 `dest` 문자열의 널 문자를 찾아서 붙여넣기를 시작하므로, `dest` 배열은 반드시 널 문자로 초기화되어 있어야 합니다.

```c
char str[80] = ""; // 널 문자로 초기화 (빈 문자열)
strcat(str, "hello");
strcat(str, " world"); // str에 "hello world"가 저장됨
```
---

## 문자열을 붙이는 `strncat` 함수

*   **기능:** 한 문자열의 끝에 다른 문자열의 일부를 이어 붙입니다.
*   **원형:** `char *strncat(char *dest, const char *src, size_t n);`
    *   `dest`: 덧붙여질 배열의 시작 주소
    *   `src`: 덧붙일 문자열의 시작 주소
    *   `n`: `src`에서 `dest`에 덧붙일 최대 문자 수
    *   반환값: `dest`
*   **동작:** `strcat`과 유사하지만, `src`문자열에서 최대 `n`개의 문자만 `dest`에 추가하고, 마지막에 항상 널 문자를 추가합니다.
*   **주의:** `strcat`과 마찬가지로 `dest`의 크기는 `dest`문자열의 길이, `src`문자열의 길이(최대 n), 널 종료 문자를 수용할 수 있을 만큼 커야합니다.

```c
char str[80] = "Hello";
strncat(str, " World", 3);   // str에 "Hello Wo"가 저장됨
strncat(str, "!!!", 2);    // str에 "Hello Wo!!" 가 저장됨
```

---

## 문자열 길이를 계산하는 `strlen` 함수

*   **기능:** 문자열의 길이(널 문자 제외)를 반환합니다.
*   **원형:** `size_t strlen(const char *str);`
    *   `str`: 길이를 측정할 문자열
    *   반환 값: 널 문자를 제외한 문자열의 길이 (바이트 단위)
*   **동작:** `str`이 가리키는 문자열에서 널 문자를 만날 때까지 문자의 개수를 셉니다.

```c
char str[] = "hello";
int len = strlen(str); // len은 5
```
---

## 문자열을 비교하는 `strcmp` 함수

*   **기능:** 두 문자열을 사전식으로 비교합니다.
*   **원형:** `int strcmp(const char *str1, const char *str2);`
    *    `str1`: 비교할 첫 번째 문자열
    *   `str2`: 비교할 두 번째 문자열
*   **동작:**
    *   두 문자열의 첫 번째 문자부터 시작하여 아스키 코드 값을 비교합니다.
    *   문자가 다르면, 해당 문자의 아스키 코드 값의 차이를 반환합니다.
    *   널 문자를 만날 때까지 모든 문자가 같으면 0을 반환합니다.
*   **반환 값:**
    *   `str1`이 `str2`보다 사전 순으로 앞서면: 음수
    *   `str1`이 `str2`보다 사전 순으로 뒤에 오면: 양수
    *   `str1`과 `str2`가 같으면: 0

```c
int result = strcmp("apple", "banana"); // result는 음수 (apple이 banana보다 앞섬)
int result2 = strcmp("banana", "apple"); // result2는 양수
int result3 = strcmp("apple", "apple");  // result3는 0
```

---

## 문자열을 비교하는 `strncmp`함수

*   **기능:** 두 문자열의 처음 n개의 문자를 비교합니다.
*   **원형:** `int strncmp(const char *str1, const char *str2, size_t n);`
    *   `str1`: 비교할 첫 번째 문자열
    *   `str2`: 비교할 두 번째 문자열
    *   `n` : 비교할 최대 문자 수
*   **동작:**
    *   `strcmp`와 유사하지만, 최대 `n`개의 문자만 비교합니다.
*   **반환 값:**
    *   `strcmp`와 반환 값이 동일
*  **대소문자를 구분하기 때문에 주의해야한다.**
```c
int result = strncmp("apple", "apricot", 3); // result는 0 ("app"까지는 동일)
int result2 = strncmp("apple", "apricot", 4); // result2는 음수 ('e' < 'r')
```
---
## 연산 함수 직접 구현 (참고)
```c
// strcpy, strncpy, strcat, strlen, strcmp 함수의 간단한 구현 예시

// strcpy: 문자열 복사
char *my_strcpy(char *dest, const char *src) {
    char *p = dest;
    while (*src != '\0') {
        *p++ = *src++;
    }
    *p = '\0';
    return dest;
}

// strncpy: n개의 문자만 복사
char *my_strncpy(char *dest, const char *src, size_t n) {
    char *p = dest;
    size_t i;
    for (i = 0; i < n && *src != '\0'; i++) {
        *p++ = *src++;
    }
    // src의 길이가 n보다 짧으면 나머지는 널 문자로 채움
    while (i < n) {
        *p++ = '\0';
        i++;
    }
    return dest;
}

// strcat: 문자열 이어붙이기
char *my_strcat(char *dest, const char *src){
    char *p = dest;
    // dest의 끝(널 문자)까지 이동
    while(*p != '\0'){
        p++;
    }
    // src를 dest 끝에 복사
    while(*src != '\0'){
        *p++ = *src++;
    }
    *p = '\0'; // 널 문자 추가
    return dest;
}

// strlen: 문자열 길이 계산
size_t my_strlen(const char *str) {
    size_t len = 0;
    while (*str != '\0') {
        len++;
        str++;
    }
    return len;
}

// strcmp: 문자열 비교
int my_strcmp(const char *str1, const char *str2) {
    while (*str1 != '\0' && *str2 != '\0' && *str1 == *str2) {
        str1++;
        str2++;
    }
    return (int)(*str1 - *str2);
}
```
