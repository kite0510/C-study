# Chapter 19. 전처리와 분할 컴파일 (Preprocessing and Separate Compilation)
---
## 19-1. 전처리 지시자 (Preprocessor Directives)

C 언어 컴파일 과정의 첫 번째 단계는 전처리(Preprocessing) 입니다. 전처리기는 소스 코드를 컴파일러에게 넘기기 전에 특정 지시자(`#`으로 시작하는 명령)를 처리하여 소스 코드를 수정하거나 확장하는 역할을 합니다.

---

### 파일을 포함하는 `#include`

*   **기능:** 지정한 파일의 내용을 읽어와 `#include` 지시자가 있는 위치에 **그대로 붙여 넣습니다.** (텍스트 삽입)
*   **사용법:**
    ```c
    #include <stdio.h>     // 시스템 헤더 파일의 내용 포함
    #include "student.h"   // 사용자 정의 헤더 파일의 내용 포함
    ```
*   **`< >`와 `" "`의 차이:**
    *   **`< >` (꺾쇠괄호):** 컴파일러가 미리 설정한 시스템 **`include` 디렉터리**에서 헤더 파일을 찾습니다. 주로 표준 라이브러리 헤더 파일(`stdio.h`, `stdlib.h` 등)을 포함할 때 사용합니다.
    *   **`" "` (큰따옴표):** **현재 소스 파일이 저장된 디렉터리**에서 헤더 파일을 **먼저** 찾습니다. 만약 해당 디렉터리에 파일이 없으면, 시스템 `include` 디렉터리에서 다시 찾습니다. 주로 **사용자가 직접 만든 헤더 파일**을 포함할 때 사용합니다.
    *   다른 디렉터리에 있는 사용자 정의 헤더 파일을 포함할 수도 있습니다 (경로 명시):
        ```c
        #include "c:/users/my_project/myhdr.h" // 절대 경로 사용 (Windows 예시)
        #include "../common/utils.h"           // 상대 경로 사용
        ```
*   **헤더 파일의 역할:**
    *   함수의 원형(prototype), 구조체 정의, 매크로 정의, 전역 변수 선언 등을 모아놓은 파일입니다.
    *   여러 소스 파일에서 공통으로 사용되는 선언들을 헤더 파일에 작성하고 `#include`하면 코드 중복을 줄이고 관리가 용이해집니다.
    *   **분할 컴파일(Separate Compilation)** 시 필수적입니다. 각 모듈(소스 파일)이 필요로 하는 공통 선언들을 헤더 파일에 모아두면, 각 모듈을 독립적으로 컴파일할 수 있습니다.
    *   헤더 파일 내용 수정 시, 해당 헤더를 포함하는 모든 소스 파일을 다시 컴파일하면 변경 사항이 일괄 적용됩니다.
    *   **주의:** `#include`는 단순히 파일 내용을 텍스트로 붙여넣는 것이므로, 실행 가능한 코드를 헤더 파일에 직접 넣는 것은 일반적으로 권장되지 않습니다 (링크 오류 발생 가능). 함수 정의 등은 소스 파일(`.c`)에 작성합니다.

---

### 매크로명을 만드는 `#define`

*   **기능:** 특정 **매크로명(Macro Name)**을 다른 **문자열(치환될 부분)**로 치환하도록 정의하는 지시자입니다. 전처리기는 소스 코드에서 매크로명을 발견하면 이를 정의된 문자열로 바꿉니다.
*   **사용법:**
    ```c
    #define PI 3.14159          // 매크로 상수 정의 (PI를 3.14159로 치환)
    #define MAX_SIZE 100        // 매크로 상수 정의
    #define GREETING "Hello!"   // 문자열 매크로 정의
    #define PRINT_MSG printf("Message: %s\n", GREETING) // 문장 매크로 정의

    // 여러 줄에 걸쳐 정의할 때 (백슬래시 사용)
    #define DEBUG_PRINT(msg) printf("DEBUG (%s:%d): %s\n", \
                                   __FILE__, __LINE__, msg)
    ```
*   **매크로명 규칙 (관례):**
    *   일반 변수와 구분하기 위해 **대문자**로 작성하는 것이 일반적입니다.
    *   매크로명과 치환될 부분 사이에는 하나 이상의 공백이 필요합니다.
*   **장점:**
    *   상수 값 등에 의미 있는 이름을 부여하여 가독성을 높입니다.
    *   여러 곳에서 사용되는 값을 한 곳에서 관리하여 수정이 용이합니다.
*   **단점:**
    *   단순 텍스트 치환이므로 예상치 못한 오류가 발생할 수 있습니다.
    *   컴파일러는 치환된 후의 코드를 보기 때문에, 오류 발생 시 디버깅이 어려울 수 있습니다. (에러 메시지가 사용자가 작성한 매크로명 위치가 아닌, 치환된 코드 위치를 가리킴)
    *   **`const` 변수나 `enum`을 사용하는 것이 더 안전하고 디버깅에 유리한 경우가 많습니다.** 필요할 때 신중하게 사용해야 합니다.

---

### `#define`을 사용한 매크로 함수 (Macro Functions)

*   **기능:** 함수처럼 인수를 받아 처리하는 매크로를 정의합니다. 함수 호출 오버헤드 없이 코드를 삽입하는 효과가 있습니다.
*   **사용법:**
    ```c
    #define 매크로함수명(인수1, 인수2, ...) 치환될부분
    #define SQUARE(x) ((x)*(x))        // 제곱을 구하는 매크로 함수
    #define SUM(a, b) ((a) + (b))      // 합계를 구하는 매크로 함수
    #define MAX(a, b) (((a) > (b)) ? (a) : (b)) // 최댓값을 구하는 매크로 함수
    ```
*   **주의사항 (매우 중요):**
    *   **괄호 사용:** 치환될 부분 전체와 각 인수는 반드시 **괄호`()`**로 묶어야 합니다. 괄호가 없으면 연산자 우선순위 때문에 예상치 못한 결과가 발생할 수 있습니다.
        ```c
        #define BAD_SQUARE(x) x*x
        int result = BAD_SQUARE(2 + 3); // 2 + 3 * 2 + 3 => 2 + 6 + 3 => 11 (오답!)
        // SQUARE(2 + 3) => ((2 + 3) * (2 + 3)) => 5 * 5 => 25 (정답)
        ```
    *   **부작용(Side Effects):** 인수로 사용된 표현식이 여러 번 평가될 수 있습니다. 증가/감소 연산자(`++`, `--`) 등을 인수로 사용하면 문제가 발생합니다.
        ```c
        int x = 5;
        int y = SQUARE(x++); // ((x++) * (x++)) => x가 두 번 증가될 수 있음 (Undefined Behavior)
        ```
*   **장점:**
    *   함수 호출 과정이 없으므로, 아주 간단하고 자주 호출되는 함수의 경우 실행 속도가 약간 빠를 수 있습니다.
*   **단점:**
    *   코드가 길어질 수 있습니다 (매크로가 사용된 곳마다 코드가 삽입됨).
    *   디버깅이 어렵습니다.
    *   부작용을 예측하기 어렵습니다.
    *   **`inline` 함수를 사용하는 것이 대부분의 경우 더 안전하고 효율적입니다.**

---

### 이미 정의된 매크로 (Predefined Macros)

C 표준과 컴파일러는 유용한 정보를 제공하는 몇 가지 매크로를 미리 정의해 놓았습니다. 디버깅 등에 활용될 수 있습니다.

| 매크로명     | 설명                                      | 형태     | 출력 형식 |
| :----------- | :---------------------------------------- | :------- | :-------- |
| `__FILE__`   | 현재 처리 중인 소스 파일의 이름 (경로 포함) | 문자열   | `%s`      |
| `__LINE__`   | 현재 처리 중인 소스 코드의 행 번호         | 정수     | `%d`      |
| `__DATE__`   | 소스 파일이 컴파일된 날짜 (Mmm dd yyyy 형식) | 문자열   | `%s`      |
| `__TIME__`   | 소스 파일이 컴파일된 시간 (hh:mm:ss 형식)   | 문자열   | `%s`      |
| `__func__`   | 현재 함수의 이름 (C99 표준 이상)         | 문자열   | `%s`      |
| `__FUNCTION__`| 현재 함수의 이름 (일부 컴파일러 지원, 비표준) | 문자열   | `%s`      |

*   `__FILE__`과 `__LINE__`의 값은 `#line` 지시자를 사용하여 변경할 수 있습니다.
    ```c
    #line 100 "new_source.c" // 다음 줄부터 행 번호 100, 파일명 "new_source.c"로 인식
    ```
*   활용 예시: 프로그램 실행 중 오류 발생 시, 오류가 발생한 파일명, 함수명, 행 번호를 출력하여 디버깅 정보를 제공할 수 있습니다.

---

### 매크로 연산자 `#`과 `##`

*   **`#` (문자열화 연산자, Stringizing Operator):** 매크로 함수의 인수를 **문자열 상수**로 치환합니다. 인수는 평가되지 않고 그대로 문자열이 됩니다.
    ```c
    #define PRINT_VAR(var) printf(#var " = %d\n", var)
    int count = 10;
    PRINT_VAR(count); // printf("count" " = %d\n", count); 로 치환 => "count = 10" 출력
    ```
*   **`##` (토큰 연결 연산자, Token Pasting Operator):** 매크로 정의 내에서 두 개의 토큰(Token)을 **하나의 토큰으로 이어 붙입니다.** 주로 변수명이나 함수명을 동적으로 생성할 때 사용됩니다.
    ```c
    #define CONCAT(a, b) a##b
    int CONCAT(value, 1) = 10; // int value1 = 10; 으로 치환
    ```

---

### 조건부 컴파일 지시자 (Conditional Compilation Directives)

소스 코드의 특정 부분을 조건에 따라 선택적으로 컴파일하거나 제외시키는 기능입니다.

*   **`#if`, `#else`, `#elif`, `#endif`:** `if-else if-else` 문과 유사하게 조건에 따라 컴파일할 코드를 선택합니다.
    ```c
    #define VERSION 2

    #if VERSION == 1
        printf("Version 1\n");
    #elif VERSION == 2
        printf("Version 2\n");
    #else
        printf("Other Version\n");
    #endif // #if 블록의 끝을 반드시 명시
    ```
    *   조건식에는 정수 상수, 매크로 상수, 산술/논리 연산 등을 사용할 수 있습니다. (괄호는 생략 가능)
    *   컴파일할 문장이 여러 개여도 중괄호 `{}`를 사용하지 않습니다.

*   **`#ifdef`, `#ifndef`, `#endif`:** 특정 매크로명이 정의되었는지 여부에 따라 컴파일할 코드를 선택합니다.
    ```c
    #define DEBUG // DEBUG 매크로 정의

    #ifdef DEBUG
        printf("Debug mode is enabled.\n"); // DEBUG가 정의되었으므로 컴파일됨
    #endif

    #ifndef RELEASE
        printf("This is not a release build.\n"); // RELEASE가 정의되지 않았으므로 컴파일됨
    #endif
    ```

*   **`defined()` 연산자:** `#if` 나 `#elif` 내에서 특정 매크로가 정의되었는지 검사할 때 사용합니다. `!` 연산자와 함께 사용하여 `#ifndef`와 같은 효과를 낼 수도 있습니다.
    ```c
    #if defined(DEBUG) && LEVEL > 2
        // DEBUG가 정의되어 있고 LEVEL이 2보다 크면 컴파일
    #endif

    #if !defined(RELEASE)
        // RELEASE가 정의되지 않았으면 컴파일 (#ifndef RELEASE 와 동일)
    #endif
    ```

*   **`#undef`:** 이미 정의된 매크로명의 정의를 취소합니다.
    ```c
    #define TEMP 100
    // ... TEMP 사용 ...
    #undef TEMP
    // 이제 TEMP 매크로는 정의되지 않은 상태
    ```

*   **`#error`:** 컴파일 과정에서 특정 조건을 만족하지 않을 때, 컴파일을 **중단**시키고 에러 메시지를 출력합니다.
    ```c
    #ifndef REQUIRED_MACRO
        #error "REQUIRED_MACRO must be defined!" // 컴파일 중단 및 메시지 출력
    #endif
    ```

*   **활용:**
    *   **플랫폼 호환성:** 운영체제나 컴파일러 환경에 따라 다른 코드를 컴파일하도록 분기할 수 있습니다.
    *   **디버깅 코드 제어:** `#define DEBUG`와 `#ifdef DEBUG`를 사용하여 디버깅 시에만 특정 코드가 컴파일되도록 할 수 있습니다.
    *   **헤더 파일 중복 포함 방지:** (아래 헤더 파일 섹션에서 설명)

---

### `#pragma` 지시자

*   **기능:** 컴파일러에게 특정 기능을 제어하거나 지시하는 표준화되지 않은 방법입니다. 컴파일러마다 지원하는 `#pragma` 지시자와 그 기능이 다릅니다.
*   **사용법:**
    ```c
    #pragma 지시명 [옵션]
    ```
*   **예시 (컴파일러마다 다름):**
    *   `#pragma pack(n)`: 구조체 멤버 정렬(padding) 방식을 제어합니다.
    *   `#pragma warning(disable: 4996)`: 특정 컴파일러 경고 메시지를 비활성화합니다.
    *   `#pragma once`: 헤더 파일 중복 포함을 방지하는 비표준적이지만 널리 사용되는 방법입니다.

---

## 19-2. 분할 컴파일 (Separate Compilation)
---

### 분할 컴파일 방법

*   **개념:** 하나의 큰 프로그램을 기능별 또는 논리적 단위별로 여러 개의 소스 파일(`.c` 파일)로 나누어 작성하고, 각 파일을 **개별적으로 컴파일**하여 **개체 파일(Object File)**(`.obj` 또는 `.o` 파일)을 생성한 후, 마지막으로 **링커(Linker)**가 이 개체 파일들과 필요한 라이브러리 파일들을 묶어서 최종 **실행 파일(Executable File)**(`.exe` 등)을 만드는 과정입니다.
*   **과정:**
    1.  소스 파일 작성 (예: `main.c`, `input.c`, `process.c`)
    2.  각 소스 파일 컴파일 (전처리 -> 컴파일 -> 어셈블) -> 개체 파일 생성 (`main.obj`, `input.obj`, `process.obj`)
    3.  개체 파일 및 라이브러리 링크 -> 실행 파일 생성 (`project.exe`)
*   **주의점:**
    *   각 소스 파일은 **독립적으로 컴파일 가능**해야 합니다. 즉, 해당 파일에서 사용하는 함수, 변수, 구조체 등에 대한 **선언**(주로 헤더 파일을 통해 `#include`)이 포함되어 있어야 합니다.
    *   모든 소스 파일이 성공적으로 컴파일된 후에 링크 과정이 수행됩니다.
    *   관련 소스 파일들은 하나의 프로젝트 디렉터리 안에서 관리하는 것이 일반적입니다.

---

### 분할 컴파일에서 `extern`과 `static`의 용도

여러 파일로 나누어 컴파일할 때, 전역 변수(Global Variable)나 함수의 **가시성(Visibility)** 또는 **연결(Linkage)**을 제어해야 합니다.

*   **`extern` (External Linkage):**
    *   **용도:** **다른 소스 파일에 정의된** 전역 변수나 함수를 **현재 파일에서도 사용하겠다**고 컴파일러에게 알리는 선언입니다.
    *   **동작:**
        *   새로운 저장 공간을 할당하는 것이 아니라, 해당 이름의 변수나 함수가 **다른 어딘가에 정의되어 있음**을 명시합니다.
        *   링커가 나중에 실제 정의를 찾아 연결해줍니다.
    *   **예시:**
        ```c
        // data.c 파일
        int global_count = 0; // 전역 변수 정의

        // main.c 파일
        #include <stdio.h>
        extern int global_count; // data.c에 정의된 global_count를 사용하겠다고 선언

        int main() {
            global_count = 10;
            printf("%d\n", global_count);
            return 0;
        }
        ```
    *   함수의 경우, 다른 파일에 정의된 함수를 호출하려면 그 함수의 **원형(prototype)**을 선언해야 하는데, 함수 원형 선언 자체가 기본적으로 `extern` 속성을 가집니다. (따라서 함수 선언 앞에 `extern`은 보통 생략합니다.)

*   **`static` (Internal Linkage):**
    *   **전역 변수/함수 앞에 `static`을 붙일 경우:**
        *   해당 변수나 함수는 **선언된 소스 파일 내부에서만 접근 가능**하게 됩니다. (파일 범위, File Scope)
        *   다른 파일에서 `extern`으로 선언해도 접근할 수 없습니다.
        *   다른 파일에 **같은 이름**의 `static` 전역 변수나 함수를 정의하는 것이 가능합니다. (이름 충돌 방지)
    *   **용도:**
        *   파일 내부에서만 사용할 변수나 함수를 숨겨서 **정보 은닉(Information Hiding)**을 구현합니다.
        *   다른 파일과의 이름 충돌을 방지합니다.
        *   **데이터 보호**에 유용합니다.

---

### 헤더 파일의 필요성과 중복 문제 해결 방법

*   **분할 컴파일에서의 헤더 파일 필요성:**
    *   여러 소스 파일에서 공통으로 사용되는 **함수 원형, 구조체 정의, 매크로, `extern` 전역 변수 선언** 등을 헤더 파일(`.h` 파일)에 모아놓고, 각 소스 파일에서 `#include`하여 사용합니다.
    *   **장점:**
        *   선언 코드를 한 곳에서 관리하여 유지보수가 용이합니다. (수정이 필요할 때 헤더 파일만 수정)
        *   코드 중복을 방지합니다.
        *   각 소스 파일이 독립적으로 컴파일될 수 있도록 필요한 선언 정보를 제공합니다.

*   **헤더 파일 중복 포함 문제:**
    *   하나의 소스 파일이 여러 경로를 통해 **같은 헤더 파일을 두 번 이상 `#include`** 하는 경우가 발생할 수 있습니다. (예: `a.h`가 `b.h`를 포함하고, `main.c`가 `a.h`와 `b.h`를 모두 포함하는 경우)
    *   함수 원형이나 `extern` 선언은 중복 선언이 가능하지만, **구조체 정의**나 **`typedef` 정의** 등은 중복될 경우 컴파일 오류가 발생합니다.

*   **중복 포함 문제 해결 방법 (Include Guard):** **조건부 컴파일 지시자**를 사용하여 헤더 파일의 내용이 딱 한 번만 포함되도록 합니다.

    ```c
    // point.h 파일 예시

    #ifndef _POINT_H_ // 1. _POINT_H_ 매크로가 정의되지 않았다면 (처음 포함될 때)
    #define _POINT_H_ // 2. _POINT_H_ 매크로를 정의한다.

    // --- 헤더 파일의 실제 내용 (이 부분이 한 번만 포함됨) ---
    struct Point {
        int x;
        int y;
    };

    void print_point(struct Point p);
    // --- 헤더 파일의 실제 내용 끝 ---

    #endif // _POINT_H_ // 3. #ifndef 블록의 끝
    ```
    *   **동작 원리:**
        1.  처음 `point.h`가 `#include` 되면, `_POINT_H_` 매크로가 정의되지 않았으므로 `#ifndef` 조건이 참이 됩니다.
        2.  `#define _POINT_H_`가 실행되어 매크로가 정의됩니다.
        3.  헤더 파일의 실제 내용(구조체 정의 등)이 소스 코드에 포함됩니다.
        4.  이후 같은 소스 파일에서 `point.h`가 다시 `#include` 되면, 이미 `_POINT_H_`가 정의되어 있으므로 `#ifndef` 조건이 거짓이 됩니다.
        5.  따라서 `#ifndef`와 `#endif` 사이의 내용(헤더 파일의 실제 내용)은 더 이상 포함되지 않습니다.
    *   **매크로명 규칙:** 다른 헤더 파일과 충돌하지 않도록 **고유한 이름**을 사용해야 합니다. 일반적으로 헤더 파일 이름을 대문자로 바꾸고 특수문자를 사용하여 만듭니다 (예: `POINT_H`, `_MY_HEADER_H_`).
    *   **`#pragma once`:** 일부 컴파일러에서 지원하는 비표준 지시자로, 헤더 파일 맨 위에 `#pragma once`를 적으면 위 Include Guard와 동일한 효과를 냅니다. 더 간결하지만 이식성이 떨어질 수 있습니다.
```
