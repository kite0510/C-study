# Chapter 4: Operators (연산자)

## 1. 나눗셈 연산 (Division Operator)
- 나눗셈 연산의 결과는 **정수 또는 실수**가 될 수 있다.  
- 따라서 결과를 저장하는 변수의 자료형을 연산에 맞게 선택해야 한다.  
- **실수 연산**에서는 **나머지 개념이 없다**, 즉 `%` 연산자는 정수형에서만 사용 가능하다.  

---

## 2. 증감 연산자 (Increment/Decrement Operator)
- `a = a + 1`과 `++a`는 같은 의미를 가진다.  
- 단, **증감 연산자의 피연산자로 상수를 사용할 수 없다**.  

---

## 3. 전위 연산과 후위 연산 (Pre/Post Increment)
- `++a` → 값을 증가시킨 후 연산에 사용.  
- `a++` → 연산에 사용한 후 값을 증가.  
- 단독으로 사용할 경우 결과는 동일하다.  
- 하지만 **하나의 수식에서 같은 변수를 두 번 이상 사용하면서 증감 연산자를 사용하면 안 된다**.  
  - **컴파일러에 따라 결과가 달라질 수 있기 때문.**  

---

## 4. 비교 연산자와 대입 연산자 (Comparison vs. Assignment)
- **0은 거짓**, **0이 아닌 값은 참**으로 간주된다.  
- `=` (대입 연산자)와 `==` (비교 연산자)를 구분하여 사용해야 한다.  
  - `=` : 값을 대입  
  - `==` : 두 값이 같은지 비교  

---

## 5. 연산자 우선순위 주의 (Operator Precedence)
- 수식 `10 < a < 20`은 `(10 < a)`가 먼저 계산되고, 그 결과가 다시 `< 20`과 비교된다.  
  - 예: `a = 30`일 때 → `10 < a`는 `1`이 되고, `1 < 20`이 되어 최종 값은 `1`이 된다.  
  - 반면, `(10 < a) && (a < 20)`를 사용하면 논리적으로 올바른 비교가 가능하다.  
  - **연산자의 우선순위를 명확하게 고려하여 논리를 구성해야 한다.**  

---

## 6. 숏 서킷 룰 (Short-Circuit Rule)
- **논리 연산자 `&&`(AND) 및 `||`(OR)** 는 **숏 서킷 룰(Short-Circuit Rule)** 이 적용된다.  
- 좌항(왼쪽) 값만으로 연산 결과가 판별되면, **우항(오른쪽) 연산을 실행하지 않는다**.  
- **장점:** 불필요한 연산을 줄여 실행 속도를 높일 수 있다.  
- **주의:** 조건문에서 예상치 못한 결과를 만들 수 있으므로, 논리 연산 순서를 잘 고려해야 한다.  

---

## 7. 연산 과정 (Operation Process)
- 연산을 수행하려면 **메모리에 있는 변수 값을 CPU의 저장 공간(레지스터)** 로 복사해야 한다.  
  - **로드(Load)**: 연산 전에 변수 값을 레지스터로 복사하는 과정  
  - **연산 수행**: CPU의 **ALU(Arithmetic Logic Unit)** 에서 연산 실행  
  - **대입(Assignment)**: 연산 결과를 다시 변수에 저장  

---

## 8. 형 변환 연산자 (Type Casting Operator)
- 형 변환 연산자는 피연산자의 값을 원하는 데이터 유형으로 **일시적 변환**한다.  
  ```c
  (double)10  // 정수 10 → 실수 10.0으로 변환

---
## 9. `sizeof` 연산자 (Sizeof Operator)
- **피연산자의 크기를 바이트 단위로 반환**한다.  
- **메모리 크기 확인**이나 **동적 메모리 할당** 시 유용하다.  
- `sizeof`는 **연산자**이므로, **괄호 사용을 권장**한다.  
  ```c
  int x;
  printf("%lu\n", sizeof(x));  // 변수 x의 크기 출력
  printf("%lu\n", sizeof(int)); // int 자료형의 크기 출력

## 10. 복합 대입 연산자 (Compound Assignment Operator)
- 연산 결과를 다시 피연산자에 저장하는 연산자이다.
- 기존 변수 값을 변경하면서 동시에 연산을 수행할 수 있다.
  ```c
  a += 5;  // a = a + 5;
  b *= 3;  // b = b * 3;
- 실행 속도를 높이고, 코드 길이를 줄이는 데 유용하다.

---

## 11. 콤마 연산자 (Comma Operator)
- 왼쪽부터 오른쪽으로 차례로 연산을 수행하며, 가장 오른쪽 피연산자가 최종 결괏값이 된다.
- 대입 연산자와 함께 사용할 때는 항상 괄호를 사용해야 한다.
   ```c
   int a;
   a = (3, 5, 7);  // 최종적으로 a에는 7이 저장됨

---

## 12. 조건 연산자 (Ternary Operator)
- 유일한 삼항 연산자로, 조건에 따라 다른 값을 반환한다.
   ```c
   int max = (a > b) ? a : b;  
   //a > b가 참이면 a를 반환, 거짓이면 b를 반환.
- 간결한 조건문을 작성할 때 유용하다.

---

## 13. 비트 연산자 (Bitwise Operators)
- 비트 단위의 논리 연산을 수행하는 연산자이다.
- **비트 시프트 연산 (Bit Shift)**
- 왼쪽 시프트 << : 비트를 왼쪽으로 이동, 빈 공간은 0으로 채움. 하나 시프트당 2씩 곱해진다.
- 오른쪽 시프트 >> : 비트를 오른쪽으로 이동, 하나 시프트당 2로 나눈 몫이 된다.
  
- **주의 사항**
- 음수일 경우, 왼쪽의 빈 비트는 1로 채워져 부호가 유지됨.
- unsigned 형으로 선언하면 왼쪽 빈 비트가 0으로 채워짐.
