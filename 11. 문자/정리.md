# Chapter 11. 문자

## 아스키 코드와 문자 입출력

*   **문자 상수:** 프로그램에서 문자를 사용할 때는 작은따옴표(`'`)로 묶습니다. `'a'`는 문자 상수, `a`는 변수명으로 해석됩니다.
*   **문자의 정수 표현:** `'a'`는 내부적으로 정수값 97(ASCII 코드)로 변환됩니다. 문자는 메모리에 정수와 같은 방식으로 저장됩니다.
    *   `int`형 변수에 문자를 저장하고, 정수처럼 연산할 수 있습니다.
    *   `'a'`를 `%d`로 출력하면 97(ASCII 코드), 97을 `%c`로 출력하면 `'a'`가 출력됩니다.
*   **char 자료형:** 문자는 1바이트 크기의 `char`형 변수에 저장하는것이 일반적입니다. 문자 상수는 4바이트이지만 컴파일러가 오른쪽 1바이트만 `char`형 변수에 저장하고 나머지는 버립니다.

---

## 아스키 코드 (ASCII: American Standard Code for Information Interchange)

*   **특징:**
    *   알파벳과 숫자는 각각 연속된 값을 가집니다.
    *   소문자가 대문자보다 ASCII 코드 값이 큽니다. (`'a' > 'A'`)
    *   제어 문자는 백슬래시(`\`)와 함께 표시되며 (예: `\n` - 개행), 출력 시 해당 기능을 수행합니다.
* **제어문자:** 형태가 없어 %c로 출력하면, 해당 제어기능이 수행된다. (데이터 통신, 출력 위치 조정 등에 사용)

---

## `scanf` 함수를 사용한 문자 입력

*   **`%c` 변환 문자:** `scanf` 함수에서 문자를 입력받을 때는 `%c`를 사용합니다.
*   **화이트 스페이스(Whitespace) 처리:**
    *   `scanf("%c", &ch);`는 공백, 탭(`\t`), 개행 문자(`\n`)도 *입력 데이터*로 처리합니다. (숫자 입력 시에는 값을 구분하는 용도로 사용되지만, 문자 입력 시에는 그 자체가 데이터)
    * 화이트 스페이스 문자도 데이터로 취급합니다.
    *   `scanf(" %c", &ch);`와 같이 `%c` 앞에 공백을 넣으면, 화이트 스페이스를 *건너뛰고* 그 다음 문자를 입력받습니다.
    *  화이트 스페이스를 제외한 문자들만 입력하고 싶다면, `%c`앞에 다른 문자를 추가하여, 입력 문자와 일치하는 문자는 버리고 다른 문자만 입력받을 수 있습니다.
    ```c
    char ch;
    scanf("A%c", &ch); // 'A'를 입력하고 다른 문자를 입력하면 ch에는 'A'를 제외한 문자가 저장됨
    ```
* `%d`를 쓰면 문자의 아스키 코드 값이 출력됩니다.

---

## `getchar`, `putchar` 함수

*   **문자 전용 입출력 함수:** 문자를 입출력할 때는 `getchar`와 `putchar`를 사용하는 것이 효율적입니다.

*   **`getchar` 함수:**
    *   매개변수가 없습니다: `ch = getchar();` (괄호만 사용)
    *   키보드로 입력한 문자의 *ASCII 코드 값*을 반환합니다.
    *   반환형은 `int`입니다. (입력의 끝을 나타내는 `EOF` (End-of-File, 보통 -1)를 처리하기 위해)
    *   공백, 탭, 개행 문자도 입력으로 받습니다. (제외하는 옵션 없음)

*   **`putchar` 함수:**
    *   `putchar(ch);`:  `ch`에 저장된 문자를 화면에 출력합니다.
    *   출력한 문자를 다시 반환하며, 출력 오류 발생 시 -1을 반환합니다.

---

## 버퍼(Buffer)를 사용하는 입력 함수

* **버퍼:** 프로그램 실행 중에 운영체제가 *자동으로* 할당하는 임시 메모리 저장 공간. 키보드 입력 데이터는 일단 버퍼에 저장된 후, `scanf`나 `getchar` 같은 함수에 의해 변수에 입력됩니다.
* **장점:**
  1.  **데이터 안정성:** 데이터를 한 번에 모아서 처리하므로 안정적입니다.
  2.  **입력 장치 독립성:** 키보드뿐만 아니라 파일 등 다른 입력 장치에서도 데이터를 읽어올 수 있습니다.
* **scanf 함수의 문자 입력 과정:**
  1.  최초 `scanf` 호출 시, 키보드로 문자열을 입력하면 버퍼에 저장.
  2.  `scanf`는 버퍼에서 첫 번째 문자만 변수에 저장.
  3.  이후 `scanf` 호출 시, 버퍼에 남아있는 문자열에서 차례대로 문자를 가져옴.
    *   **주의:** Enter 키를 누르면 개행 문자(`\n`)도 버퍼에 함께 저장되므로, `\n`도 하나의 데이터로 입력될 수 있습니다.
* **변환 문자의 역할:**
    *   `scanf` 함수에서 변환 문자(`%d`, `%c`, `%lf`, `%s` 등)는 버퍼에 저장된 문자열을 어떤 *형태*로 변환하여 변수에 저장할지를 지정합니다.
    *   예: `%d`는 문자열을 정수로 변환, `%c`는 문자 하나로 변환, `%lf`는 double형 실수로 변환.

---

## `scanf` 함수 반환값 활용

*   **`scanf` 함수의 반환값:** `scanf` 함수는 *성공적으로* 입력받은 항목의 *개수*를 반환합니다. 입력 형식과 일치하지 않거나, 입력 오류가 발생하거나, 파일의 끝(EOF, End-of-File)에 도달하면 `-1` (즉, `EOF`)을 반환합니다.

*   **입력 종료 신호:** 개행 문자(`\n`)도 입력 데이터로 처리하는 경우(예: `%c`를 사용하는 경우), 입력 종료를 위한 별도의 신호가 필요합니다. 이때 `scanf` 함수의 반환값을 활용할 수 있습니다.
    *   **Windows:** Ctrl + Z 키를 누른 후 Enter 키를 누릅니다.
    *   **Unix/Linux/macOS:** Ctrl + D 키를 누릅니다.
    *   이렇게 하면 `scanf` 함수는 `-1` (EOF)을 반환합니다.

```c
// 예제: scanf 함수의 반환값을 사용하여 입력 종료
int res;
char ch;

while (1) { // 무한 루프
    res = scanf("%c", &ch); // 문자 하나를 입력받음
    if (res == -1) {  // EOF 또는 입력 오류 발생
        break;      // while 루프 종료
    }
    printf("%d ", ch); // 입력된 문자의 아스키 코드 값 출력
}
```

---

*   **동작 과정 설명:**
    1.  `while (1)`: 무한 루프를 시작합니다.
    2.  `res = scanf("%c", &ch);`: `scanf` 함수를 사용하여 문자 하나를 입력받고, 그 결과를 `res`에 저장합니다.
        *   사용자가 문자를 입력하고 Enter를 누르면, 해당 문자와 개행 문자(`\n`)가 입력 버퍼에 저장됩니다.
        *   `scanf("%c", &ch)`는 버퍼에서 문자 하나를 읽어 `ch`에 저장하고, 성공적으로 1개의 항목을 읽었으므로 `1`을 반환합니다.
        *   만약 사용자가 Ctrl+Z (Windows) 또는 Ctrl+D (Unix/Linux/macOS)를 눌러 EOF를 입력하면, `scanf`는 `-1`을 반환합니다.
    3.  `if (res == -1) break;`: `res`가 `-1`이면 (즉, EOF 또는 입력 오류), `break` 문을 실행하여 `while` 루프를 종료합니다.
    4.  `printf("%d ", ch);`: 입력받은 문자(`ch`)의 아스키 코드 값을 출력합니다.
    5.  `while` 루프의 조건이 항상 참(`1`)이므로, 사용자가 EOF를 입력할 때까지 2~4 단계를 반복합니다.

*   **숫자 입력의 내부 처리 과정:**
    1.  **문자열 형태로 버퍼에 저장:** 키보드로 숫자를 입력하면, 숫자는 *문자열 형태*로 입력 버퍼에 저장됩니다. 예를 들어, `123`을 입력하면, 문자 `'1'`, `'2'`, `'3'`이 순서대로 버퍼에 저장됩니다.
    2.  **변환 문자에 따른 변환:** `scanf` 함수는 *변환 문자* (예: `%d`, `%f`, `%lf`)에 따라 버퍼에 있는 문자열을 해당 자료형(정수, 실수 등)으로 *변환*하여 변수에 저장합니다.
        *   `%d`: 문자열을 정수로 변환합니다.
        *   `%f`: 문자열을 `float` 형 실수로 변환합니다.
        *   `%lf`: 문자열을 `double` 형 실수로 변환합니다.
        *   `%c`: 문자 하나를 그대로 가져옵니다.
        *   `%s`: 문자열을 가져옵니다 (공백, 탭, 개행 문자로 구분).

## `getchar` 함수를 사용한 문자열 입력

*   **목표:** 키보드로부터 한 줄의 문자열(a string of characters)을 입력받아 `char` 배열에 저장하는 함수를 만들어 보겠습니다.
*   **핵심 함수:** `getchar()`
    *   `getchar()`는 입력 버퍼에서 *문자 하나*를 읽어옵니다.
    *   매개변수가 없으며, 호출 시 괄호만 사용합니다: `ch = getchar();`
    *   반환형은 `int`입니다. (EOF, 즉 -1을 처리하기 위해서입니다.)
*   **구현:**

```c
void my_gets(char *str, int size) {
    int ch;
    int i = 0;

    // getchar()를 반복 호출하여 문자열을 읽어옴
    while ((ch = getchar()) != '\n' && ch != EOF) {
        // 배열 범위 초과 방지 (널 문자 공간 확보)
        if (i < size - 1) {
            str[i++] = ch; // 읽어온 문자를 배열에 저장하고 인덱스 증가
        }
    }
    str[i] = '\0'; // 문자열 끝에 널 문자('\0') 추가 (C 스타일 문자열)
}
```
*   **`void my_gets(char *str, int size)`:**
    *   `char *str`: 입력받은 문자열을 저장할 `char` 배열(의 시작 주소)을 가리키는 포인터.
    *   `int size`: `str` 배열의 크기 (바이트 단위).

*   **`int ch;`:** `getchar()`의 반환값(문자 또는 EOF)을 저장할 변수.

*   **`while ((ch = getchar()) != '\n' && ch != EOF)`:**
    *   `ch = getchar()`: `getchar()`를 호출하여 입력 버퍼에서 문자 하나를 읽어 `ch`에 저장.
    *   `!= '\n'`: 읽어온 문자가 개행 문자(`\n`)가 *아닌* 동안 반복. (한 줄 입력을 처리하기 위함)
    *   `&& ch != EOF`: 읽어온 문자가 EOF (파일 끝, Ctrl+Z 또는 Ctrl+D)가 *아닌* 동안 반복.

*   **`if (i < size - 1) { str[i++] = ch; }`:**
    *   `i < size - 1`:  `str` 배열의 범위를 *초과하지 않도록* 검사합니다.  `-1`은 문자열 끝에 추가할 널 문자(`\0`)를 위한 공간을 확보하기 위함입니다.
    *   `str[i++] = ch;`:  `ch`에 저장된 문자를 `str` 배열의 `i`번째 위치에 저장하고, `i`를 1 증가시킵니다.

*   **`str[i] = '\0';`:**  입력받은 문자열의 끝에 *널 문자*(`\0`)를 추가합니다.  C 언어에서 문자열은 널 문자로 종료되는 문자 배열로 표현됩니다 (C 스타일 문자열).

---

## 입력 버퍼 지우기

*   **문제 상황:** `scanf` 함수와 `getchar` 함수는 *같은 입력 버퍼*를 공유합니다.  따라서, 이전의 `scanf` 호출에서 버퍼에 남겨둔 데이터(특히, 개행 문자)를 이후의 `getchar` 또는 `scanf("%c", ...)` 호출에서 의도치 않게 읽어올 수 있습니다.
    *   예: `scanf("%d", &num);`으로 정수를 입력받은 후, Enter 키를 누르면 개행 문자(`\n`)가 입력 버퍼에 남습니다. 이후에 `ch = getchar();`를 호출하면, 사용자가 새로운 문자를 입력하기도 전에 `ch`에는 `\n`이 저장됩니다.

*   **해결책:** `getchar();`를 호출하여 입력 버퍼에 남아있는 불필요한 문자를 *제거*합니다. 주로 개행 문자(`\n`)를 제거하는 데 사용됩니다.

```c
#include <stdio.h>

int main() {
    int num;
    char grade;

    printf("학번 입력: ");
    scanf("%d", &num);  // 정수 입력 (학번)
    getchar();           // 입력 버퍼에 남아있는 개행 문자 제거

    printf("학점 입력: ");
    grade = getchar();  // 문자 입력 (학점)

    printf("학번: %d, 학점: %c\n", num, grade);
    return 0;
}
```
---

## getchar();의 역할:

*scanf("%d", &num); 실행 후, 입력 버퍼에는 개행 문자(\n)가 남아있습니다.

*getchar();를 호출하면 입력 버퍼에서 이 개행 문자(\n)를 읽어와서 버립니다.

*이렇게 버퍼를 비워주면, 다음 getchar() 호출 시 사용자가 원하는 문자를 제대로 입력받을 수 있습니다.
