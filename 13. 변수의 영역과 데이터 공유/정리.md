# Chapter 13. 변수의 영역과 데이터 공유

---

## 지역 변수 (Local Variables)

*   **정의:** 함수 내부 또는 특정 블록 `{}` 내에 선언되는 변수입니다.
*   **`auto` 키워드:**
    *   원래는 `auto` 예약어와 함께 사용해야 하지만, 생략 가능합니다.
    *   함수 내에 선언된 변수는 `auto`를 생략해도 자동으로 지역 변수로 간주됩니다.
*   **특징:**
    1.  **사용 범위 제한:** 선언된 블록 내부에서만 사용할 수 있습니다. 다른 함수나 블록에서는 접근할 수 없습니다.
    2.  **독립적인 저장 공간:** 이름이 같더라도, 다른 함수나 블록에 선언된 지역 변수는 서로 다른 메모리 공간을 할당받습니다.
    3. **매개변수**: 함수의 매개변수도, 함수 내에서만 접근 가능한 지역변수이다.
*   **장점:**
    1.  **메모리 효율성:** 블록이 끝나면 지역 변수에 할당된 메모리가 자동으로 반환되므로, 메모리를 효율적으로 사용할 수 있습니다.
    2.  **디버깅 용이성:** 변수의 사용 범위가 제한되므로, 값이 잘못된 경우 해당 블록만 확인하면 됩니다.
*   **주의사항:** 지역 변수는 자동으로 초기화되지 *않습니다*.  따라서 사용하기 전에 반드시 초기화해야 합니다.  초기화하지 않으면 쓰레기 값(garbage value)이 사용될 수 있습니다.

---

**블록 내 지역 변수 규칙:**

1.  특정 블록 내에 변수를 선언하면, 그 변수의 유효 범위는 해당 블록 내부로 제한됩니다.
2.  사용 가능한 변수가 둘 이상인 경우 (예: 외부 블록과 내부 블록에 같은 이름의 변수가 있는 경우), *가장 가까운 블록*에 선언된 변수가 사용됩니다. (변수 shadowing)

---

## 전역 변수 (Global Variables)

*   **정의:** 함수 외부(파일의 맨 위)에 선언되는 변수입니다.
*   **사용 범위:** 프로그램 전체에서 접근할 수 있습니다.
*   **초기화:** 전역 변수는 *자동으로 0으로 초기화*됩니다. (지역 변수와 달리)
*   **전역 변수 vs. 지역 변수:**
    *   전역 변수와 지역 변수의 이름이 같은 경우, 해당 블록 내에서는 *지역 변수가 우선*됩니다. (전역 변수는 가려짐, hidden)

*   **전역 변수 사용 시 문제점:**
    1.  **이름 변경의 어려움:** 전역 변수의 이름을 변경하면, 그 변수를 사용하는 *모든* 함수를 수정해야 합니다.
    2.  **디버깅 어려움:** 전역 변수의 값이 잘못된 경우, 그 변수에 접근 가능한 *모든* 함수를 의심해야 합니다.
    3.  **가독성 저하:** 전역 변수가 많아지면 코드의 가독성이 떨어지고, 유지보수가 어려워집니다.

* **권장 사항:** 전역 변수는 꼭 필요한 경우가 아니면 *최대한 사용하지 않는 것*이 좋습니다. 전역 변수 대신, 함수 매개변수나 정적 지역 변수 등을 활용하는 것이 더 좋은 프로그래밍 습관입니다.

---

## 정적 지역 변수 (Static Local Variables)

*   **정의:** 지역 변수처럼 특정 블록 내에서 선언되지만, `static` 예약어를 사용하여 선언됩니다.
*   **사용 범위:** 선언된 블록 내부로 제한됩니다. (지역 변수와 동일)
*   **저장 기간:** 프로그램이 시작될 때 메모리에 할당되고, 프로그램이 종료될 때까지 *값을 유지*합니다. (전역 변수와 유사)
*   **초기화:**  *처음 한 번만* 초기화됩니다. (초기화를 생략하면 0으로 자동 초기화)
*   **활용:** 함수 호출 사이에 값을 유지해야 하는 경우에 유용합니다. 예를 들어, 함수 호출 횟수를 세거나, 이전 호출 결과를 저장하는 데 사용할 수 있습니다.

---

## 레지스터 변수 (Register Variables)

*   **정의:** 변수 선언 시 `register` 예약어를 사용합니다.
*   **저장 공간:** CPU 내의 *레지스터*(register)에 변수를 저장하도록 *요청*합니다. (컴파일러가 반드시 이 요청을 받아들이는 것은 아닙니다.)
*   **목적:** 데이터 처리 속도를 높이는 것. 레지스터는 메모리 중에서 가장 빠른 저장 공간입니다.
*   **활용:** 반복문에서 자주 사용되는 변수(카운터 변수 등)를 레지스터 변수로 선언하면, 프로그램 실행 속도를 향상시킬 수 있습니다. (현대 컴파일러는 최적화를 잘 해주기 때문에 `register` 키워드의 효과가 크지 않을 수 있습니다.)

*   **주의사항:**
    1.  전역 변수는 레지스터 변수로 선언할 수 없습니다. (레지스터는 CPU의 자원을 잠시 빌리는 것이므로)
    2.  레지스터 변수는 *주소 연산자(&)를 사용할 수 없습니다*. (메모리에 주소가 없기 때문)
    3.  레지스터 사용 여부는 *컴파일러가 결정*합니다.  레지스터가 부족하거나, 변수의 크기가 레지스터보다 큰 경우, 컴파일러는 `register` 키워드를 무시하고 일반적인 지역 변수로 처리합니다.

---

## 함수 간 데이터 공유 방법

---

### 1. 값에 의한 호출 (Call by Value)

*   **정의:** 함수를 호출할 때, 변수의 *값*을 복사하여 전달하는 방식입니다.
*   **특징:**
    *   호출된 함수(callee) 내에서 매개변수의 값을 변경해도, 호출한 함수(caller)의 원래 변수에는 *영향을 주지 않습니다*.
    *   변수뿐만 아니라, 상수나 수식도 인수로 전달할 수 있습니다.
*   **용도:**
    *   함수가 입력값을 받아서 처리하고, 그 결과를 반환값으로 돌려주는 경우 (입력값을 변경할 필요가 없는 경우)
    *   값을 출력하거나, 연산하는 경우

---

### 2. 주소에 의한 호출 (Call by Reference)

*   **정의:** 함수를 호출할 때, 변수의 *주소*를 전달하는 방식입니다.
*   **특징:**
    *   호출된 함수(callee) 내에서 매개변수(포인터)를 통해 호출한 함수(caller)의 변수에 *직접 접근*하여 값을 변경할 수 있습니다.
*   **구현:**
    *   호출하는 쪽: `&` 연산자를 사용하여 변수의 주소를 전달합니다.  `func(&a);`
    *   호출받는 쪽:  `*` (포인터)를 사용하여 매개변수를 선언합니다. `void func(int *pa);`
* **용도:**
    *   호출된 함수가 호출한 함수의 변수 값을 *변경*해야 하는 경우
    *   여러 개의 값을 반환해야 하는 경우 (C 언어의 함수는 하나의 값만 반환할 수 있으므로)

---

### 3. 주소 반환 (Returning a Pointer)

*   **정의:** 함수가 *주소*를 반환하는 방식입니다.
*   **가능한 경우:**
    *   *정적 지역 변수*의 주소
    *   *전역 변수*의 주소
    *   (드물게) 동적으로 할당된 메모리의 주소 (이 경우는 메모리 관리에 주의해야 합니다.)
*   **주의사항:**
    *   반환값의 자료형은 반환값을 저장할 포인터의 자료형과 *일치*해야 합니다.
    *   *절대* *지역 변수*의 주소를 반환해서는 안 됩니다. 함수가 종료되면 지역 변수는 소멸되므로, 반환된 주소는 유효하지 않은 메모리 영역을 가리키게 됩니다. (댕글링 포인터, dangling pointer)

---

## 추가 팁

* **`const` 키워드 (함수 매개변수):** 함수 내에서 매개변수의 값을 변경하지 않도록 하려면, 매개변수를 `const`로 선언하는 것이 좋습니다.
  *   `void print_value(const int a);`  (값에 의한 호출)
  *   `void print_array(const int *arr, int size);` (주소에 의한 호출)
* **전역 변수 vs. `static` 전역 변수:**
  * 일반적인 전역 변수: 다른 파일에서도 `extern` 키워드를 사용하여 접근할 수 있습니다.
  * `static` 전역 변수: 선언된 파일 내에서만 접근할 수 있습니다. (다른 파일에서는 접근 불가) - 정보 은닉(information hiding)에 유용
