# Chapter 9: 포인터 (Pointers)

지금까지는 변수를 사용하여 메모리에 접근했습니다. 이번 장에서는 메모리의 주소 값을 이용하여 메모리에 접근하는 **포인터**에 대해 알아봅니다. 변수는 선언된 블록, 즉 함수 내부에서만 사용할 수 있지만, 포인터를 사용하면 사용 범위를 벗어난 경우에도 메모리에 접근할 수 있습니다.

## 메모리의 주소 (Memory Address)

메모리는 데이터를 넣고 꺼내 쓰는 공간이며, 각 위치는 고유한 주소 값으로 식별됩니다.  주소는 바이트 단위로 구분되며, 0부터 시작하여 1씩 증가합니다.

*   **2바이트 이상 크기의 변수:** 여러 개의 주소 값에 걸쳐 할당됩니다.
    *   예: `int`형 변수 `a`가 메모리 100번지부터 할당되었다면, 100~103번지까지 4바이트에 걸쳐 할당됩니다. 이 4바이트 전체를 `a`라는 이름으로 사용합니다.
    *   `a = 10;`은 4바이트 공간에 10을 저장합니다.
    *   `a + 20;`은 이 4바이트에 저장된 값과 20을 더하는 연산을 수행합니다.
---

## 주소 연산자 (&)

*   **주소:** 변수가 할당된 메모리 공간의 *시작 주소*를 의미합니다.
*   **주소 연산자 (`&`):** 변수의 시작 주소를 구하는 데 사용됩니다.
    *   `&변수명`: 변수가 할당된 메모리 공간의 시작 주소 값을 반환합니다.
*   **주소 출력:** 일반적으로 16진수로 표기하며, `%p` 형식 지정자를 사용하는 것이 좋습니다.

---

## 포인터와 간접 참조 연산자 (*)

*   **포인터 선언:**  `자료형 *변수명;`
    *   예: `int *pa;` (정수형 변수의 주소를 저장할 수 있는 포인터 `pa` 선언)
*   **포인터 변수:** 선언되면 일반 변수와 마찬가지로 메모리에 저장 공간이 할당됩니다.
*   **주소 대입:** `pa = &a;` (포인터 `pa`에 변수 `a`의 주소를 대입)
    *   변수 `a`가 메모리 100번지부터 103번지까지 할당되었다면, 주소 값 100이 `pa`에 저장됩니다.
    *   이제 `pa`는 변수 `a`가 메모리 어디에 할당되었는지 그 위치를 "가리킵니다".
    *   `pa`와 `a`의 관계를 `pa -> a` 와 같이 화살표로 표현할 수 있습니다.
*   **간접 참조 연산자 (`*`) (또는 포인터 연산자):** 포인터가 가리키는 변수를 사용할 때 사용합니다.
    *   `*pa = 10;` :  `pa`가 `a`를 가리키므로, `*pa`에 10을 대입하면 `a`에 10을 대입하는 것과 같습니다.
    *   `*pa`는 대입 연산자의 왼쪽에 올 때는 `pa`가 가리키는 변수의 *저장 공간*으로 사용됩니다.
    *   `*pa`는 대입 연산자의 오른쪽에 올 때는 `pa`가 가리키는 변수의 *값*으로 사용됩니다.

---

## 여러 가지 포인터 사용

*   **포인터 선언과 동시에 초기화:** `int *pt = &total;` (변수 `total`의 주소로 포인터 `pt`를 초기화)
*   포인터는 가리킬 변수의 자료형과 *동일한* 자료형으로 선언해야 합니다.
* 포인터에 `&`를 사용해 주소를 대입하고 나서는, `*`를 사용하여 가리키는 변수를 사용할 수 있습니다.

---

## `const`를 사용한 포인터

`const` 예약어를 포인터에 사용하면, 포인터를 통해 가리키는 변수의 값을 변경할 수 없습니다.

```c
int a = 10;
const int *pa = &a; // pa는 const int* 형

// *pa = 20;  // 컴파일 에러: pa를 통해 a의 값을 변경할 수 없음
a = 20;      // 가능: a는 const 변수가 아니므로 직접 변경 가능
pa = &b     // 가능: 포인터 변수 pa가 다른 변수를 가르키도록 바꾸는건 가능.

```

---

## 포인터 이해하기

*   **포인터:** 주소를 저장하는 *일정한 크기*의 메모리 공간입니다.
*   포인터는 언제든지 다른 주소를 저장하거나, 포인터끼리 대입할 수 있습니다.
*   **대입 연산:** 엄격한 기준이 적용됩니다 (가리키는 변수의 자료형이 같아야 함).

### 주소와 포인터의 차이

| 구분     | 주소                                                         | 포인터                                                        |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 의미     | 변수에 할당된 메모리 저장 공간의 *시작 주소 값 자체* (상수)   | 주소 값을 저장하는 *또 다른 메모리 공간* (변수)             |
| 특징    | 변경 불가능                                     | 다른 주소 저장 가능, 포인터끼리 대입 가능                  |
| 예시 | `&a` (변수 `a`의 주소)       | `int *pa = &a;` (`pa`는 `a`의 주소를 저장하는 포인터 변수) |

### 주소와 포인터의 크기

*   **포인터의 크기:** 저장할 주소의 크기에 따라 결정됩니다. (일반적으로 32비트 시스템에서는 4바이트, 64비트 시스템에서는 8바이트).
*    모든 주소와 포인터는 가리키는 자료형에 관계없이 *크기가 같습니다*.
*   `sizeof` 연산자로 주소와 포인터의 크기를 확인할 수 있습니다.
    ```c
    char ch;
    int in;
    double db;

    char* pc = &ch;
    int* pi = ∈
    double* pd = &db;
    // 주소의 크기 출력 (시스템에 따라 4바이트 또는 8바이트)
    printf("char형 변수의 주소 크기 : %zu\n", sizeof(&ch));
    printf("int형 변수의 주소 크기 : %zu\n", sizeof(&in));
    printf("double형 변수의 주소 크기 : %zu\n", sizeof(&db));

    // 포인터의 크기 출력 (주소 크기와 동일, 시스템에 따라 4바이트 또는 8바이트)
    printf("char * 포인터의 크기 : %zu\n", sizeof(pc));
    printf("int * 포인터의 크기 : %zu\n", sizeof(pi));
    printf("double * 포인터의 크기 : %zu\n", sizeof(pd));

    // 포인터가 가리키는 변수의 크기 출력
    printf("char * 포인터가 가리키는 변수의 크기 : %zu\n", sizeof(*pc)); // 1 (char)
    printf("int * 포인터가 가리키는 변수의 크기 : %zu\n", sizeof(*pi));  // 4 (int)
    printf("double * 포인터가 가리키는 변수의 크기: %zu\n", sizeof(*pd)); // 8 (double)

    ```

### 포인터의 대입 규칙

*   포인터는 *가리키는 변수의 형태(자료형)가 같을 때만* 대입해야 합니다.
*   *형 변환*을 사용한 포인터의 대입은 언제나 가능하지만, 주의해서 사용해야 합니다.  잘못된 형 변환은 예기치 않은 결과를 초래할 수 있습니다.

---

## 포인터를 사용하는 이유

*   **메모리 직접 접근:** 임베디드 프로그래밍 등에서 하드웨어 메모리에 직접 접근해야 하는 경우.
*   **동적 메모리 할당:** 프로그램 실행 중에 필요한 만큼 메모리를 할당하고 해제하는 경우 (동적 할당은 이후 챕터에서 다룹니다).
*   **Call by Reference (참조에 의한 호출):** 함수 호출 시 변수의 값을 복사하는 대신(Call by Value), 변수의 주소를 전달하여 함수 내에서 *원본 변수의 값을 변경*할 수 있도록 하는 경우.
    *   예: 두 변수의 값을 교환하는 `swap` 함수

```c
// Call by Reference를 사용하여 두 변수의 값을 교환하는 함수
void swap(int *pa, int *pb) {
    int temp;
    temp = *pa;
    *pa = *pb;
    *pb = temp;
}

int main() {
    int a = 10, b = 20;
    swap(&a, &b); // a와 b의 주소를 전달
    printf("a: %d, b: %d\n", a, b);  // 결과: a: 20, b: 10
    return 0;
}
